
12 其他重要的一元运算
=====================

12.1 原型的范围
---------------

为了测试 unum 的优点，我们需要在科学计算器按钮上能找得到的那种功能。
原型中\ *未*\ 包含的一类函数是反三角函数，例如反正切。
这些留给读者作为练习； 本书中的任何实验都不需要它们。

“一元”运算是仅采用一个输入值并产生一个输出值的运算。 与基本的\ :math:`+`
:math:`-` :math:`\times` :math:`\div`\ 运算和 :math:`x^y`
函数不同，一元运算仅将 **ubismoved** 计数增加一个输入和一个输出 ubound
中的位计数，并将 **numbermoved** 增加 2 而不是 3

关于三角函数的部分包含一个有点激进的建议，它巧妙地解决了第 5.4.2
节中提到的参数减少问题，但可能需要一些时间来适应。

12.2 绝对值
-----------

通常，绝对值函数是可以想象到的最简单的任务：将符号位设置为零。 对于
unums 和 ubounds，绝对值有一些需要注意的事项。
如果区间端点都小于零，我们必须记住反转区间端点的顺序。
如果零位于区间内，则闭零是下界，端点绝对值的最大值是右侧端点。
问题又是在细节上，详细信息参见附录 C.16。

请注意，当取反反转值的左右位置时，它们会携带打开或关闭状态。 因此，代表
:math:`[-3, -2)` 的 ubound 的绝对值应该是 :math:`(2, 3]` ：

.. figure:: assets/image-20230627083036422.png

   image-20230627083036422

尽管该操作看起来微不足道，\ **absu** 仍会更新 **ubitsmoved** 和
**numbermoved** 计数。
当端点交换位置时，需要移动数字和比特，这需要能量。 也可能没有必要有一个
g-layer 版本，而这些东西显然可以在 u-layers
中完成，而无需任何暂存器设施，但为了完整性，它也包含在原型中。

12.3 自然对数，及以 2 为底的对数
--------------------------------

自然对数 :math:`e^x` 的逆运算具有三个特殊的精确值。 0、1 和
:math:`\infty` 的对数分别恰好是 :math:`–\infty`\ 、0 和
:math:`\infty`\ 。 当然，对于任何负实参，我们都会返回
NaN，因为那里的对数是复值。 **logg** 和 **logu** 的代码在附录 C.16 中。
下面是求范围 [0, 1] 的对数的示例，结果具有特别精确的界限：

.. figure:: assets/image-20230627085144237.png

   image-20230627085144237

与指数函数一样，如果我们使用 2 而不是 e
作为基数，我们可以从对数函数得到更精确的结果。
这里有一个反复出现的主题：当有类似的函数承诺对某些精确输入提供精确答案时，为什么要在几乎所有地方使用不精确的函数？
如果将该原理应用于三角函数，则会带来许多计算优势。

12.4 三角函数：逐渐结束疯狂
---------------------------

当学生第一次学习三角学时，通常会以度为单位介绍角度。
每个人都知道“180度”和“45度”这样的角度，即使他们从未学过三角学。
后来，微积分及以上级别的课程教授弧度是测量角度的更好方法，因为导数和微分方程的公式看起来更简单。
由于高等数学的影响力，所有标准语言库都使用弧度作为正弦、余弦、正切等的参数。
如果要计算 90° 的正弦，则必须在浮点数词汇表中尽可能接近弧度等效值
:math:`\pi/2`\ 。 想象一下要求 90° 的正切； 使用略低于 :math:`\pi/2`
的浮点数会产生一个巨大的正数，但使用略高于 :math:`\pi/2`
的浮点数会产生一个巨大的负数。

弧度的使用放弃了表达精确问题的精确答案的有用机会。
**那么为什么不使用度数而不是弧度来定义三角函数呢**\ ？ 如果您要求 30
度的正弦，您将得到正好 1/2 。 135 度的正切值正好是 –1。 正切的 unum
函数知道返回 NaN 作为精确 90° 角的正切。

一旦你决定使用弧度，你就放弃了使用浮点数或
unum表示的数字来达到这样一个特殊角度值的希望。
在这方面，计算机就像人类一样：它们使用度数比使用弧度更容易！

而且使用度的好处比这要更大：它解决了参数减少的问题。 回想一下第 5.4.2
节中的示例，其中计算一个大数的三角函数需要使用\ :math:`\pi`\ 来“展开”其值，使用大量位来存储到\ :math:`\pi`\ 到足够的精度。
如果我们只需要知道一个大浮点数除以整数 180 的余数怎么办？
这根本不需要太多工作，当然也不需要存储数百位超越数 :math:`\pi` 的值。
如果有人提出愚蠢的请求，要求计算机将 :math:`10^{100}`
的余弦值视为精确数字，以度为单位则参数\ :math:`10^{100}`\ 度 与 10
度完全相同。

该原型包含几个三角函数，但不是完整的集合：

.. figure:: assets/image-20230627092840256.png

   image-20230627092840256

区间界限的方法是将下界参数减少到接近零的可管理范围，然后将上限参数减少到比下界大不超过两个周期的值。
这可以捕获函数在输入区间内某处具有最小值或最大值的情况。
例如，想象一下绕单位圆的 2/3，从 60° 到
300°，两端的角度间隔都开放的情况如下图：

.. figure:: assets/image-20230627093333316.png

   image-20230627093333316

余弦是该角度区间的水平投影，其范围从 –1 到 cos(60°) =
1/2，但函数值在右侧打开（蓝色条在右侧圆角化，以显示这一点） 。

.. figure:: assets/image-20230627093531906.png

   image-20230627093531906

正弦是该角度间隔的垂直投影，虽然 sin(60°) 和 sin(300°) 不能表示为精确的
unum 值，但这并不重要，因为总体界限是单位圆的整个范围， 闭区间：

.. figure:: assets/image-20230627093629473.png

   image-20230627093629473

定义了基本操作后，我们准备开始尝试测试问题来比较 unum 和 float。
然而，还有一点未完成的事情：可以融合的操作的定义，即在
g-layer中计算，使得返回到 u-layer 的值达到 u-layer 环境可能的最高精度。
这就是确保可移植性（跨计算机系统的位相同结果）同时提高准确性的原因。
它与 Java 使用的方法相反，在 Java
中，通过简化操作以匹配最不准确的系统的操作来确保位相同的结果。
具有明确定义的融合运算的结果之一是，它可以大大减少数值表示中对小数和指数字段位数的需求。
