
小结
====

Unum
用有限位数的表示整个实数轴，并定义了无需舍入、上溢或下溢的计算环境。
正如浮点数将缩放信息合并到数字中以便更容易在计算机上进行数学运算一样，unum
通过合并数字的精确或不精确状态、精度位数和动态范围，将这一想法更进一步。
在实践中，浮点数通常使用的尺寸过大，以防止可能破坏结果的事情发生。 由于
unum
会自动缩放所需的位数，因此它们通常使用比浮点数更少的位数，但会产生更准确的答案，并带有可证明的界限。

.. figure:: assets/image-20230628112429713.png

   image-20230628112429713

对 unum
最大的反对原因可能来自于它们的大小是可变的，至少当它们以打包形式存储时是这样。

您在上面看到的是两个相同的句子，一个使用等宽字体
(Courier)，另一个使用字体大小完全相同的可变宽度字体 (Times)。
请注意可变宽度字体使用的空间少了多少。
曾经有一段时间（在施乐帕洛阿尔托研究中心和苹果公司将帕洛阿尔托研究中心的显示技术商业化之前），计算机总是显示等宽字体，因为系统设计者认为管理可变宽度字母的文本显示是难以置信的困难。
“M”或“@”的最坏情况宽度决定了每个字母的宽度，包括“l”或“;”。
使用固定宽度的字体，易读性会受到影响，并且需要更多的纸张和墨水来传达相同的信息，但对于工程师来说事情变得更容易，因为他们必须弄清楚在屏幕或打印页面上将字母形式的像素放置在哪里。
Unums
与浮点数之间的权衡与可变宽度字体与固定宽度字体相同：对于设计工程师来说更困难，对于计算机来说逻辑电路更多，但在可用性、紧凑性和总体成本方面对其他人来说更优越。

更少的位数意味着 unum
将比任何带宽受限的计算机中的浮点数更快，这几乎是当前正在构建的每台计算机。
除了节省存储和带宽（从而减少能量和功耗）之外，能够将 unum
解压到具有“汇总位”的固定大小寄存器存储中，并且无需舍入逻辑，这意味着大部分任务
为 unums 设计硬件比为浮点设计更容易，并且 unums 需要的芯片上门延迟更少。

有些人假设任何严格跟踪区间边界的计算总是比等效的浮点例程占用更多的存储空间；
实际的 unum 实验（例如第 14.5 节中的 FFT）表明，如果使用
ubounds（而不是传统的间隔方法）来跟踪间隔，则不一定出现这种情况。

对于那些未受过舍入误差危险训练的人来说，使用 unums 和 ubounds
编程比使用浮点数编程要安全得多。
它们提供了即使是区间算术也无法达到的数学严谨性。
它们包含的有关其自身不精确性的信息使计算机能够自动管理大部分或全部的数值分析负担。
仔细定义暂存器计算中允许的内容可以保证从一个计算机系统到另一个计算机系统的完美的、按位相同的结果，甚至允许
unum 遵守代数的结合律和分配律。
这让我们在执行更改计算顺序或分组（包括软件并行化）的操作时能区分编程错误和舍入错误。

.. raw:: html

   <table border="2">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightblue">

然而，还有一些未完成的事情。 由于 unum
界限类似于区间算术，我们如何知道它们不会遭受与传统区间相同的命运，产生比应有和需要宽松得多的界限？
如果我们已经有一个为浮点数设计的算法，我们如何让它与 unums
一起工作，而不需要程序员了解区间算术及其危险？ 有一个通用的解决方案，即
ubox 方法。

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

这是第二部分的内容了。

.. figure:: assets/image-20230628120342688.png

   image-20230628120342688

https://en.wikipedia.org/wiki/E_pluribus_unum

https://zh.wikipedia.org/wiki/%E7%BE%8E%E5%9B%BD%E5%9B%BD%E5%BE%BD

拉丁文格言“合众为一”（E Pluribus Unum）
