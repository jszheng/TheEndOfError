
6 每个比特的信息
================

+-----------------------------------+-----------------------------------+
| |image-20200730175908923|         | |image-20200730175929594|         |
+===================================+===================================+
| 亚伯拉罕                          | 林肯头像高准确度，但              |
| 林肯，低准确度但是高精度，149,47  | 是低精度。只有432个像素，但是马上 |
| 2个像素。多数人不知道这是在画谁。 | 就知道是谁。做对比做精细更重要。  |
+-----------------------------------+-----------------------------------+

6.1 信息是不确定性的倒数
------------------------

还记得关于传统区间算术浪费位的抱怨吗?
两个固定大小的浮点数来表示边界，那么要么你有一个紧边界（这表示两个数字中的大部分位相同，因此是冗余的），或者边界是松散的（这意味着两个浮点的精度都超过了合理需要的范围）。Unums和ubound不仅比传统的间隔更有效，而且还提供了一种自动或者根据程序员的要求来管理信息与存储比率的方法

.. raw:: html

   <table border="2">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightblue">

信息或答案质量与边界的宽度成反比。如果您对答案没有任何边界，则您的信息为零，因为答案的边界为[-∞,
+∞] ，

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

我们使用计算机为我们提供有关某些东西的信息，无论是从现在开始三天下雨的机会还是投资组合的估计价值，或者是在附近可以找到好的咖啡的地方。

对于只需要处理整数（或定点）问题的计算机人员来说，用实数来衡量信息的想法似乎是奇怪的，他们的问题的结果要么获得答案，要么就没有答案。
大多数计算机科学学位是通过解决整数世界问题的作业，例如“找到在棋盘上安排八位国际象棋皇后的方式，使他们彼此之间不能互相攻击。”

涉及实数的程序需要跟踪并最大化有关答案的信息。
他们还需要优化获得的信息与计算时间比。
这通常意味着优化信息与比特数的比率，因为移动比特占了大部分时间。
熟悉克劳德·香农（Claude
Shannon）对“信息”的定义的读者可能会注意到概念上的相似之处。

我们需要在军械库补充更多工具，以使得计算机自动或让用户来选择运行速度与精度的权衡。

6.2 把ubound归一化(unification)到一个ULP
----------------------------------------

假设我们使用的是{4，6}环境（能够支持IEEE双精度），并且unum计算的结果是间隔(12.03，13.98)，表示为ubound。
由于ubound是一对unum，因此需要122位存储空间。
这比传统的区间算术更紧凑，但是对于表达一个“大约在十二到十四之间”的值它仍然占用了太多位了。
答案信息量是边界宽度的倒数，约为：

.. math::


   \frac{1}{14-12}=\frac{1}{2}

所以我们可以优化这个ubound来只使用一个unum去表示(12,
14)区间，并接受这个答案信息的损失。这共使用了17比特。从122比特到17比特意味着每比特信息量提升了7倍。

对于中间计算结果放松ubound可能不是个太好的主意，但是当我们把最后答案放进主存储器或者呈现给用户作为最后答案的时候，
提升每比特信息比是有意义的。但是跟浮点舍入不同的是放松ubound边界应该永远是\ **显式**\ 的，\ **可选**\ 的命令

在一个理想的unum计算环境中，归一化的功能应该全部硬件实现使得它足够快。这里的原型是转换为等效电路的逻辑描述。

6.3 原型中的Unification
-----------------------

6.3.1 有损压缩的可选项
~~~~~~~~~~~~~~~~~~~~~~

在原型中\ **unify**\ [ub]函数试图找出一个unum能够包含ubound
**ub**\ 表示的区间，如果能的话，否则ub不做任何更改就返回。结果要么是精确的，要么就是一ULP宽。如果不精确，本方法是找到找到一个ULP用来描述分离的两个边界，将每个边界表示为ULP值的倍数，如果它们的差别不恰好是一个ULP，将ULP大小翻倍。最终我们可以找到一个单独的ULP间隔，可以用一个不精确的unum表示。我们不能unify一个跨越0、±1、或±2或±3的范围，因为最粗的unum数不包括这些点，有特殊代码来处理这个情况。\ **unify**\ 代码见附录C.6。

在构造unum算术运算时，通常对左边界和右边界是分开计算的。
unify例程可以是最后一步，它可以发现是否有可能将答案无损压缩成单个unum。
例如，在计算开区间(1，4)的平方根时，该算法会找到左右端点的平方根，用ubit将它们标记为开放，并最初将其存储为一个ubound对\ :math:`\lbrace \hat{1}+ ubitmask， \hat{2}-ubitmask \rbrace`\ 。
但是，该ubound对代表与\ :math:`\lbrace \hat{1} + ubitmask \rbrace`
相同的常规间隔，因为ULP宽度为1。无损压缩无需用户允许，unum算术应尽可能自动执行此操作。

作为原型的一个示例，我们可以unify一个间隔(23.1 23.9)的ubound。
在{3，4}环境中，需要57位来表示两部分的ubound：

.. figure:: assets/image-20200804161609983.png

   image-20200804161609983

函数\ **nbits**\ [u]计算ubound u的位数,
包含一个或两个unum数的总比特数，和额外一比特指示是单个或是一对unum表示的。(
57 = 2*28+1 )

.. figure:: assets/image-20200804162316853.png

   image-20200804162316853

现在我们计算\ :math:`\textbf{unify} \left [ \lbrace \hat{23.1}, \hat{23.9} \rbrace \right ]`,
结果是一个数的ubound，需要的比特数少好多

.. figure:: assets/image-20230615143639753.png

   image-20230615143639753

看上去像一个16比特的数，多出一比特是表征只有一个数表示的范围

.. figure:: assets/image-20230615143826644.png

   image-20230615143826644

这个答案的信息量掉了些，因为表征的边界范围宽了些。范围扩大的比例是\ :math:`\frac{24-23}{23.9-23.1}=1.25`,
所以信息量减小比例是倒数\ :math:`\frac{23.9-23.1}{24-23}=0.8`\ ，约有20%的减少。但是表示的比特数目提高了\ :math:`\frac{57}{17}=3.35\cdots`\ 。所以每一比特表征的信息量提升比是\ :math:`0.8 \times 3.35 \cdots = 2.68 \cdots`

尽管unum的哲学是尽量自动地做误差控制，但是总是有个选项是切换的人工选择，因为有关精度和代价(包括存储容量，能耗，执行时间)的折中可能只能人来判断，而且不同应用也不一样。有一个简单的方法给计算机一个指导原则而不是用户在每一个点都要人工做决定。

6.3.2 智能归一化
~~~~~~~~~~~~~~~~

unum的环境中可以定义一个policy决定什么时候可以把一个准确的bound换成一个更粗一点的bound来达到省存储或带宽的目的。比如policy可以是每比特信息量提升比例超过\ :math:`r`\ （可以是自动或者程序员手动设置这个门限）才值得去做。这种智能其实也是人手工计算判断时候用的一种方法。
这个函数原型是\ :math:`\textbf{smartunify}[u,r]`,
其中\ :math:`u`\ 是ubound，\ :math:`r`\ 是提升比例门限值。

如果比例设为1.0表示我们要得到同样或是更好的每比特信息。设为0.25表明我们接受下降到四分之一的信息量。使用1.5则是要求必须提升到1.5倍的信息量。

也可以定义其他更复杂的policy。

下面样例要求每比特信息量提升3倍才转换，结果是不改变原来的ubound,
因为找不到提升那么多的简化方法。

.. figure:: assets/image-20230615150914021.png

   image-20230615150914021

而如果放低要求到2.5就能找到，如下

.. figure:: assets/image-20230615150940207.png

   image-20230615150940207

原型定义的\ **smartunify**\ 函数源代码可以在附录C.6找到。读者可以想想有没有其他的policy来管理误差和最大化每比特信息量。比如可以还是保留两个端点的bound，但是端点数用更少的比特来表示。比如在{3,
5}环境中，一个表示(23.1, 23.9)的ubound要求每个端点用完整的32bit
fraction。但是端点间相差的距离远大过于这么精细的小数位表示，以至于可以考虑放松这个bound为(23.0625,
23.9375),
其端点的小数仅仅需要用8bit表示。这样使得总存储从91bit变成了43bit，提升比为2.1但是信息量只放松了9%，所以总的每比特信息量提升了1.9倍。

你可以想象把提升门限r定义为环境，跟esizesize和fsizesize一样。就像压缩音乐是视频，有时候你需要小的存储容量，有时候又需要高保真度。程序员还是需要做一些初始的决定，然后计算机根据指导原则做最艰苦的工作来管理如何计算。

有时候非常激进的要每一步操作后都做unification看上去很像significance
arithmetic，只是不像significance
arithmetic那么有局限(不能表示左右端点为非精确数)。这么做对于有限的一些场景，比如需要输入数据而且输出前只执行一小段计算，通常来讲，最好是等到最好计算结束后再来看看有没有机会来提升每比特的信息。

6.3.3 特别处理“几乎没有”和“几乎无穷大”
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

尽管任何一个环境中只有一种方式表达精确的\ :math:`-\infty`\ 和\ :math:`+\infty`,
但是有无穷种方法表达一个下界为\ :math:`-\infty`\ 或是上界\ :math:`+\infty`\ 的开区间。这个原型代码中，为了节省我们使用了最紧凑的表达方式，定义为常量\ **negopeninfu**\ 和\ **posopeninfu**\ 。比浮点数处理无穷代价更少。

相对应的有一个表示几乎是0的开区间，使用最小的unum表达。负数的上限是unum
= (-1, 0)，定义为\ **negopenzerou**\ 。相对的正数下限是unum = (0, 1),
也就是\ **ubitmask**\ 表示的数。

对于一个环境，上面的常数对应的unum就是，可以在setup时候就产生出来：

.. figure:: assets/image-20230615160607032.png

   image-20230615160607032

这些值只需要在utag左边添加三比特 （utag= 1 0s 0s）

例外是如果环境是{0, 0}, 那么\ **negopeninfu** = (:math:`-\infty`,
:math:`-2`), 而\ **posopeninfu** = (:math:`2`, :math:`+\infty`)

.. raw:: html

   <table border="2">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightgray">

读者的练习: 上面表中utag左边三比特是什么？

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

假设我们想表达一个范围(-0.3, :math:`\infty`), 在一个中等精度的环境{3,
4}中.
一个比较昂贵的方式表达右侧开无限空间的方式是使用\ **maxreal**\ ，加上\ **ubitmask**\ ，
表示的unum是

.. math::


   （680554349248159857271492153870877982720， \infty）

这个unum消耗33比特附加8比特utag.
我们最终丢弃了左端点的很大的数，只用了右端点做ubound的右端点。如果我们改用\ **posopeninfu**\ ，
那么只需要utag加三比特。

所以最后的压缩表示方法表示ubound :
{:math:`-\hat{0.3}, \textbf{posopeninfu}`}是

.. figure:: assets/image-20230615162105888.png

   image-20230615162105888

整个ubound只需要39比特来表示。

6.4 ubound能比浮点更省空间吗？
------------------------------

前面我们提到unum通常比浮点更省存储空间。那么ubound呢，有很大可能是需要两个unum而不是一个unum，那么是否有希望比一个定长浮点更省呢？而且假设不常去做unification。我们先来看unum对比float的存储需求对比。

你也许会猜想实际应用中大多数都是不精确数，所以常常需要用最长的比特数表示值和utag，结果会占用比float更多空间。其实不然，原因有以下5个。

**原因1：指数位浪费**\ 。浮点数中的指数在实际计算中常常是过度使用了，unum通常会用更少的指数位。
即使是单精度IEEE浮点有85个数量级的跨度，而你在什么样的程序中会看到有这样的动态范围的使用呢？如果一个单精度的计算值范围持续在-500到+500中，你只需要4bit指数。保持在这个范围的数可以节省4bit，如果是双精度浮点节省7bit，四精度浮点节省11比特。

**原因2：准确值没有去掉尾部的0**\ 。对于完全随机的准确数，最低比特有50%可能性为0，
25%可能性最低两比特为0，
以此推演平均去掉尾部0就可以节省\ :math:`\frac{1}{2^1}+\frac{2}{2^2}+\frac{3}{2^3}+\cdots=2`\ bits

就上面两条就可以挣回添加utag的开销。

**原因3：常用的数长度短**\ 。时间使用中的计算中常使用小的整数和简单的分数。翻翻任何一本物理或是数学课本，你能看到很多像\ :math:`-1, 3, \frac{1}{2}, 4`\ 这样的数据。在公式中，比如计算动量\ :math:`\frac{1}{2}mv^2`\ 中的\ :math:`\frac{1}{2}`.
传统的浮点计算使用64比特表示1.0就有相当多的浪费：

.. figure:: assets/image-20230615164623489.png

   image-20230615164623489

而unum中存储1.0只需要占用3bit 0，0，1。在一个支持到双精度的{4,
6}的环境中，1.0只需要15比特表示:

.. figure:: assets/image-20230615164813866.png

   image-20230615164813866

unum在表达小整数乘2的幂次的数是很简洁的，这种数在计算中比你想象的要常见得多。

**原因4：左边数消去节省**\ 。加减数通常导致小数左右两边的有效数消去。unum可以聪明地发现并压缩消去的比特。这依赖于计算，需要大量实验来了解能节省的量。

**原因5：不做超额保险**\ 。计算有了bound保证，可以让用户能声明需要多少十进制位数，而不是为了保险要尽量多的数位。即便是半精度的浮点也在很多重要的应用都绰绰有余，比如勘探石油的地质数据，或是医学扫描图像。

很多情况下，即使是一对unum总比特数也比用单精度浮点少。所以ubound在严格的算术中最终还是经济的方法。这个比较不是太公平，因为float通常产生错误的结果而unum给出正确的答案。许多情况下这已经不是需要折中了，我们可以用更少的比特得到更精确的结果。而且不要忘了到结果最终输出到外部存储器，通常我们会做unification到一个单一的unum，需要两个unum的ubound主要发生在芯片内部的计算。

有些人认为解决舍入误差的方法是推进四精度的硬件实现。那是一个错误的方向，会双倍增加每个操作的能量，功耗，带宽和存储占用。而且还是不能给出计算最终结果的信息丢失的度量。更有意思的是走另外一个方向，问：

到底多小的unum字串还能用于实数的计算上。

.. |image-20200730175908923| image:: assets/image-20200730175908923.png
.. |image-20200730175929594| image:: assets/image-20200730175929594.png
