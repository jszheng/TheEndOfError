
1 概论
======

.. figure:: assets/image-20200707162605636.png

   image-20200707162605636

.. raw:: html

   <center>

“你不能把大海煮到沸腾。” —前英特尔高管对unums的想法做出的回应.

.. raw:: html

   </center>

.. raw:: html

   <center>

附带说一下unum发音是“ you-num”，并且用小写字母拼写。

.. raw:: html

   </center>

The **u**\ niversal **num**\ ber (通用数字)
或’\ **unum**\ ’包含了所有标准浮点格式(floating point)，以及定点(fix
point)和精确整数运算(exact integer arithmetic)。
unum比浮点运算获得更准确的答案，且在许多情况下使用较少的位，从而节省了内存，带宽，能量和功率。
与浮点数（floats）不同，unums不会产生舍入错误，并且不会溢出或下溢。
听起来似乎用有限的位数是不可能的，但这就是unum所能做到的。
unum对于浮点数如同浮点数对于整数一样是个超集。

**unum arithmetic**\ 算术比\ **interval
arithmetic**\ (间隔算术)更严格，但使用的存储位却少得多。
unum计算环境可以动态地自动调整精度和动态范围，因此程序员\ *无需*\ 选择要使用的精度;
因此它比浮点算术更易于使用和更安全。
与浮点数不同，unum算术保证在不同计算机上得到\ *完全逐位相同的答案*\ 。
它的主要缺点是需要更多的逻辑门才能在芯片中实现，但是现代芯片可以很便宜地拥有大量逻辑门。
而\ **内存带宽**\ ，\ **能效比**\ 和\ **编程人员的生产力**\ 则非常宝贵且受到限制。
unums帮助解决所有三个问题。
现在是时候用更好的东西来补充具有百年历史的浮点算法了：unum算法。

现在是时候煮沸海洋了。

1.1 更少的比特数，更好的结果
----------------------------

.. figure:: assets/image-20200707165444622.png

   image-20200707165444622

.. raw:: html

   <center>

100岁生日快乐，浮点数。我们仍在使用为第一次世界大战时代的计算技术设计的数字格式。

.. raw:: html

   </center>

用看起来像\ *科学计数法*\ (scientfic
notion)的数字进行自动计算的想法可以追溯到1914年（Leonardo Torres y
Quevado）。科学记数法将数字表示为两个部分的乘积，例如“
:math:`6.022\times10^{23}`\ ”，其中\ :math:`6.022`\ 是小数部分，“
:math:`10^{23}`\ ”中的23是指数。如果必须使用整数来表示该值，那么无论是在纸上还是在计算机系统中，它都会占用更多的空间：

.. math::


   602,200,000,000,000,000,000,000,000,000

指数可以为负也可以为正，因此小数点的位置可以左右浮动，以表示非常大或非常小的数字。托雷斯·奎瓦多（Torres
y Quevado）在1914年提出的在自动计算机中使用此类数字的建议,
并应用在了1941年左右（康拉德·祖斯Konrad
Zuse的Z3）机器中，其使用的是基数2（二进制）而不是基数10（十进制）。
Zuse的计算机可以存储16位分数和6位指数的数字，例如

.. math::


   1.0001110111010001 \times 2^{110100}

左右浮动的是“二进制点”而不是“十进制小数点”

但是，每台早期的计算机设计在表示浮点值和算术行为方面都各有不同。
经过数十年的不兼容之后，电气与电子工程师协会（IEEE，通常发音为“ I Triple
E”）委员会标准化了格式和1980年代中期的某些行为。 该标准称为IEEE 754。
阅读此介绍的化学家会将\ 

.. math:: 6.022\times10^{23}

\ 识别为物理常数，称为“阿伏加德罗数”，这是元素或化合物的标准原子或分子数。
化学家几乎总是坚持使用双精度(double)作为他们的计算机模拟的精度。
在IEEE双精度中，阿伏加德罗Avogadro常数的四位的近似数字看起来像是这长长的一堆比特位：

.. math::


   (-1)^0 \times 2^{10 001 001 101-1023} \times 1.1111111000010101010011110100010101111110101000010011

.. raw:: html

   <table border="2">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightyellow">

令人惊讶的是，IEEE标准不要求使用相同格式的不同计算机产生相同的结果！
鼓励使用隐藏的“保护数字”(guard
digits)以提高舍入答案的准确性，即使这样做的代价是造成不同计算机系统的结果之间令人困惑的不一致。
Java编程语言的开发人员很惊讶地发现，将浮点数指定为IEEE标准并不能保证任何计算机上的结果都相同。
Java解决方法是禁用所有提高准确性的隐藏方法。

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

现在，我们有几种不同的IEEE标准二进制浮点精度：16位（半精度），32位（单精度），64位（双精度）和128位（四精度）。目前程序员必须选择他们认为适合其应用程序的精度。如果选择的太少，则结果精度可能太低，或者可能动态范围不足以代表最大值和最小值（上溢和下溢）。如果他们选择了太多的精度，那么他们的应用程序将消耗不必要的存储空间，带宽，能量和运行功率，当然，运行速度也会变慢。
由于能耗或功耗限制了许多计算机－从移动设备（我们一直希望更长的电池寿命）到巨型数据中心（在可用空间或设备成本用光之前就消耗可用的兆瓦的功耗），也许是时候重新检查这个具有百年历史的浮点格式的概念，看看是否还有更好的方法。
“更好”是指：

-  更易于使用
-  更准确
-  对内存和带宽的要求降低
-  更少的能源和电力消耗
-  保证在不同计算机上给出按位相同的结果
-  在大多数情况下，速度更快。

假设我们希望以IEEE原理为基础，但是能够将精度和动态范围更改为最佳位数，并且还可以记录该数字是准确的还是在范围内，而不是四舍五入。
我们可以通过附加使数字具有自描述性的其他位字段来实现。
将此称为“通用数”或unum。

   **定义**\ ：unum是具有六个子字段的可变长度的位串：符号位，指数，分数，不确定性位，指数大小和分数大小。

快速预览下unum格式的样子：

.. figure:: assets/image-20200707175337458.png

   image-20200707175337458

左边的三个字段类似于IEEE浮点，但具有更好的规则来表示非数字Not-a-Number（NaN）和无穷大，和处理上溢，下溢和舍入的更好方法。它用不确定性位uncertain
bit，或简称ubit（带有“ cubit”的押韵）来实现。

   **定义**\ ：ubit是unum格式的一个标志位，如果unum为精确，则为0；如果unum表示两个精确unum之间的开放间隔，则为1。

ubit类似于表达式“:math:`2\div3=0.666...`”中的“…”。这意味着在分数的最后一位之后还有更多位，不是全为0，也不是全为1，而是未指定。
ubit不会舍入，而是存储结果位于可表示的精确值之间的事实。

ubit还标记了值介于\ **最大可表示实数和无穷**\ 之间，或介于\ **最小幅度可表示数与零**\ 之间的情况。
ubit允许unum处理那种浮点数会将溢出\ **上溢到无限**\ 或\ **下溢到零**\ 的情况，做法是将它们视为精确定义的范围，\ **绝不**\ 不与无穷或零混淆。简而言之，unum对它是否完全了解所表示数值是诚实的。
Unums通过将不确定性明确化并将其存储在数字自我描述中来管理不确定性。

最后两个字段指示指数和分数中的位数，每次计算都允许两者都改变，这很像浮点数中的每次计算改变二进制点位置的方式。
（它们的偏移量为1，因此，例如，如果指数大小的位为\ :math:`010 = 2`\ ，则指数字段的宽度为3位，小数部分的宽度也是如此。）描述该字段的位数指数大小和分数大小在环境中设置。

这些字段可以小到零位宽。在那种极端的情况下，所有的unum只有四位：一个符号位，一个指数位，一个小数位，以及一个ubit，指示小数是精确值还是值范围。事实证明，超短的unum位字符串是令人惊讶的强大工具。

那是unums的解释的快速版本。随后的各章系统地处理了unum格式。与浮点格式优于定点格式一样，unum方法将被证明比计算机通常存储实数的方式具有一些惊人的优势。一方面，与浮点数相比，unum简洁，可以节省存储空间和带宽，并降低硬件的功耗和能源需求。更重要的是，unum永远不会像浮点运算那样用数学准确的数值去代替附近的数值。他们在数学上很诚实，并且在不同的计算机上给出按位相同的答案。

在硬件实现中，unum数比浮点数需要更多的逻辑，但是晶体管已经变得如此便宜，以至于我们欢迎任何能够使用它们的新事物。如果计算机能够对精度和动态范围做出大多数决策而程序员再不必做了，那岂不是更好吗？

1.2 为什么更好的算术可以节省功耗与面积
--------------------------------------

.. figure:: assets/image-20200707181809976.png

   image-20200707181809976

..

   .. raw:: html

      <center>

   现代处理器芯片的散热结构比芯片本身大数百倍。
   一个140瓦的芯片具有与电炉顶上的线圈大约相同的功率密度

   .. raw:: html

      </center>

当人们被告知现代计算机上的算术使用很少的能量，而更多的能量用于移动数据时，许多人感到惊讶。
那是因为晶体管已经变得更快，更便宜且更节能，但是连接它们的导线仍然相对较慢，昂贵且低能效。
以下是2010年时代技术的一些测量结果，其中“ pJ”为皮焦耳：

=================== ============ ======
操作类型            近似能量消耗 位置
=================== ============ ======
64b 浮点乘加        64 pJ        芯片内
读写64b的寄存器数据 6 pJ         芯片内
从DRAM读64b数据     4200 pJ      芯片外
=================== ============ ======

从表上看信息很明确：大量的能量消耗是用于片外数据运动，而不是芯片内部的数学运算。

如果处理器具有足够的CPU核和乘法器-加法器单元，以每个时钟频率（在3
GHz频率下）执行32个浮点运算，则其总和仅为6瓦。在芯片内移动数据是相当低的功耗，因为这些线是及其细微的，但是在外部DRAM之间来回移动数据意味着需要驱动人眼可见的芯片之间连线，功耗相比是巨大的。这就是为什么将双精度浮点数移动到处理器中所需的能量是执行乘法和加法所需的能量的60倍以上。随着晶体管的改进，该比率还在增加。

打个比方：假设您购买了汽车保险，但您不知道自己的汽车值多少钱。因此，您做出保守的猜测，并声明这辆汽车的价值是其实际价值的十倍，只是为了确保您在发生事故的情况下得到了保障。后来却因为收到了让人吃惊的高昂费用帐单而感到愤怒。

计算机用户要求计算机来回移动十五位的十进制数字也是对灾难的过度保险。用户不知道所需的小数位数是多少，因此他们要求太多。然后他们感到愤怒的是程序运行速度太慢并且消耗了太多的电能。

这里的目的不是要劝说计算机用户在评估其精度需求方面做得更好。他们本不应该去做这样的工作。他们应该指定输入值的精度以及希望在输出值的精度。要求双精度或任何精度，都是混淆了手段与目标。计算机应管理自己的精度需求以达到要求的精度目标，它可以比任何程序员都做得更好。但是首先，计算机需要一种数字格式，使其能够达到这个目的。
