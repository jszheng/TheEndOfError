
13 融合操作（一次性表达式）
===========================

.. figure:: assets/image-20230627094357246.png

   image-20230627094357246

..

   用于执行复杂算术的标准库例程因担心“从世界的边缘掉下来”而受到削弱，因为简单的算术可能会在临时计算中上溢或下溢。
   这些例程通常将浮点输入分解为指数和分数部分以避免此问题，这会破坏浮点运算硬件的大部分速度优势。
   本章提出了一种更好的方法，通过声明融合运算并明确其使用，来避免可表示实数集“掉落边缘”。

13.1 标准化一组融合操作
-----------------------

本章讨论的是建立标准融合表达式的可能性，其中输入值仅使用一次，或“单次使用表达式”。
第 2 部分将探讨多项式或 :math:`x + \frac{1}{x}`
等融合表达式的完美计算，其中输入值会多次使用，因为此类计算自引入以来就是困扰着区间算术的新挑战。

必须有严格的规则来规定允许计算链在暂存器层中保留多长时间以及什么类型的计算，以避免不切实际的暂存器存储需求。
否则，程序员会忍不住要求整个程序在暂存区中运行，只有在完全完成后才近似得到答案！

即使是简单的计算也可以很快生成数十亿位，因此我们在考虑哪些操作应该以融合形式提供时要谨慎。

13.2 融合乘加和融合乘减
-----------------------

正如第 5
章所讨论的，融合指令应始终表示为不同的操作，以便程序员知道正在使用哪一个。
这避免了不同计算系统给出的令人费解的不同答案的问题。
如果聪明的编译器想要用乘法融合来代替乘法加法，则必须在源代码中明确该替换，并在编译之前作为选项提供给程序员。

对于加法，累加器只需略大于小数位数。
对于融合乘加，累加器需要两倍的位数，因为它将在进行加法之前保存完整的乘积（对于
{4, 5} 环境，最多 66 位）。 这对于硬件来说是很小的代价。

计算机制造商倾向于不支持单独的融合乘减指令，因为它与操作数取反并执行融合乘加相同。
由于求反是一种完美的操作，不会丢失任何信息，因此这像是一个合理的决定。
在本章中，我们将不把减法作为一种特定运算，因为它总是可以通过加上负数来完成，结果是完美的。

注意到融合乘加很像 Kulisch 的 EDP
想法，其中乘积以扩展精度进行累加，然后返回到工作区的精度水平。
不同于点积的是累加器中已经存在一个数字，且向量的长度为 1。

在原型中，g-layer 函数 **fmag**\ [:math:`ag`, :math:`bg`, :math:`cg`]
精确计算一般区间 :math:`ag`\ 、\ :math:`bg` 和 :math:`cg` 的
:math:`(ag \times bg) + cg`\ 。 u-layer 函数 **fmau**\ [:math:`au`,
:math:`bu`, :math:`cu`]
与其等效，如果可能则返回精确的答案，否则返回在最小可用 ULP
宽度内的答案。 同样的，u-layer 例程还记录移动的数字个数和总位数。 对于 3
个输入和 1 个输出，\ **numbersmoved** 计数增加 4。 **ubitsmoved**
计数增加 ubound 输出中的位数以及 3 个 ubound 输入中的位数；
注意暂存器层中的位的移动没有被记录。

这意味着 **fmau**\ [:math:`au`, :math:`bu`, :math:`cu`]
使用的带宽比单独执行\ :math:`(au \odot bu) \oplus cu` 操作要少，它移动了
:math:`(au \odot bu)` 两次（结果从 g-layer 到 u-layer，然后返回到
g-layer 作为输入）。
距离处理器越远，在计算机中移动位的成本就会增加，我们在这里使用近似值，即暂存器位移动是无成本的，而
u-layer 位移动则需要一些成本，无论是片外存储还是片上存储缓存。 **fmag**
和 **fmau** 的代码如附录 C.13 所示

为了说明融合乘加的优点，即使是 Warlpiri unum 也足够了。 如果我们将
:math:`(2 \times 2) - 2` 作为单独的操作来计算，那么当返回到 u-layer 时
:math:`2 \times 2`
就会变成“很多”，尽管返回了正确的边界，但信息都丢失了：

.. figure:: assets/image-20230627105659670.png

   image-20230627105659670

作为融合操作，答案在 u-layer 中保持精确且可表达：

.. figure:: assets/image-20230627105805151.png

   image-20230627105805151

13.3 解决复数数学运算缓慢的悖论
-------------------------------

即使早期版本的 Fortran 也支持 COMPLEX（一对单精度浮点数）和 DOUBLE
COMPLEX（一对双精度浮点数）来表示数字 :math:`a + bi`\ ，其中
:math:`i = \sqrt{-1}` 。 支持复数的最新语言（C 语言在 1999
年标准化了复数数据类型）与那些早期的 Fortran 版本有一个奇怪的缺点：

.. raw:: html

   <table border="2">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightyellow">

如果您不使用 COMPLEX 类型，而是详细说明如何使用 REAL 和 DOUBLE
变量类型获取复杂运算的实部和虚部，那么性能会好得多！

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

应用程序程序员对此摸不着头脑很久了。
使用计算机供应商提供的优化库怎么可能会慢呢？ 复数 :math:`z = a + bi` 和
:math:`w = c + di` 的乘积为

.. math::


   z \times w = (a \times c - b \times d) + (a \times d + b \times c) i

此运算应进行四次浮点乘法、一次浮点减法和一次浮点加法来确定实部和虚部。
为什么在程序中写入“:math:`z \times w`”会导致其运行速度比转换complex\ :math:`(a \times c-b \times d,a \times d+b \times c)`\ 慢得多？

原因是程序员和计算机系统之间缺乏关于需求和让步的沟通，导致隐藏的暂存区提供了不必要的帮助。
优化的库例程的设计考虑到了溢出或下溢的恐惧，这很像对驶离地球边缘的恐惧。

假设 a、b、c 和 d 是浮点数可以表示的非常大或非常小的数值，无论精度如何。
如果 :math:`a \times c` 上溢或下溢怎么办？ 如果
:math:`a \times c - b \times d` 是可表示的数字，但临时计算的
:math:`a \times c` 和 :math:`b \times d`
超出了可表示值集合的边缘怎么办？
大多数程序员并不要求他们的复数计算有效，即使数字数字非常大或非常小，但他们没有办法向计算环境表达这种让步。
因此，库设计者假设用户要求复杂的运算适用于浮点类型的整个动态范围。
这意味着复杂的运算必须仔细剖析浮点数以重新调整指数以防止上溢或下溢，进行算术运算，然后替换指数。

难怪这样的方式运行得如此缓慢：它们将快速的硬件降低到软件模拟的速度，就因为担心会脱离可表示的边缘。
用户没有办法告诉计算机系统：“我不打算使用\ :math:`10^{-150}`\ 到\ :math:`10^{150}`\ 动态范围之外的数字，所以请直接进行用硬件进行复数运行。

融合操作彻底解决了这个问题。 :math:`a \times c - b \times d` 和
:math:`a \times d + b \times c` 都是长度为 2
的向量的点积。这意味着任何具有融合点积指令的系统都已经具备在暂存器内进行复数乘法的能力，从而防止错误地落在动态范围之外
中间计算。 Kulisch 的 EDP 操作理念看起来一直是很好。
下一节将介绍如何使用 unum 硬件构建，特别是使用 unum 的解压寄存器形式。

**读者的练习**\ ：创建复数除法 :math:`\frac{a+bi}{c+di}`
的融合运算，假设暂存器可以保存 :math:`c^2 + d^2` 和其他临时值。
需要多少个精确累加器才能避免计算两次？

13.4 完整累加器的 Unum 硬件
---------------------------

13.4.1 未打包的 unum 环境中的成本
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

为了在不损失精度的情况下累加乘积，可以将累加器想象为一个非常大的定点数，在二进制小数点的两侧有足够的位，以便任何两个浮点数的乘积落在该范围内的某个位置。
在 IEEE 单精度中执行此操作大约需要 600 位，而在 IEEE 双精度中则需要 4000
位。 决定精确累加器大小的主要因素是动态范围。 如果您将其视为
size是subnormal 的 ULP 数量，则位串必须足够大才能表示整数
:math:`\frac{maxreal}{smallsubnormal}` 。
扩展精度算术不必每次都对所有这些位进行运算。 精确 unum
的任何乘积的结果都是最多 :math:`2^{fsizesize+1} - 1` 位的整数。

将位“移位”到正确的位置很像写入内存地址，如果将 4000
位视为一个内存块，那么寻址 4K 内存似乎并不困难。 寄存器必须比
:math:`\frac{maxreal}{smallsubnormal}`
更大，以允许将最大数重复添加到累加器中；
它只在累加器的长度上添加了几十位，以防止溢出，即使对于天文数字般的累加也是如此。

如果我们对最高可达 {4, 5} 环境的 unum
提供直接硬件支持，则指数范围甚至比四倍精度 IEEE 浮点数更大。
使用最大动态范围（大约 :math:`10^{-9874}` 到
:math:`10^{9864}`\ ）意味着精确累加器需要大约 66000 位。
用于这么多存储的很可能只能放在主（一级）缓存，而不能用寄存器存放。

理想情况下，需要有两个这样的寄存器，因此 EDP
的左右间隔端点可以并行累加。 累积的乘积始终被视为精确的，即使它们是把
ubit 置位以指示不精确范围的 unum。 这是 unum
算术与重要性算术有何不同的另一个例子。 例如，如果您手工计算并发现 200
位数字的累加大约超过17位，那么您很可能会从该点开始将
17位右侧的每个数字都作为不值得跟踪的垃圾丢弃。 但它不是垃圾。
每个乘积都会产生非常精确定义的实数范围，在端点处开放或封闭。
只有在所有累加结束时，才有可能知道总数的下限和上限，然后将其返回到
u-layer ，在 u-layer中它可能或可能无法准确表示，但最多会损失最小的
ULP大小的边界宽度。

回想一下，对于 {4, 5} 环境，可以构建乘法器硬件来获取高达 33
位的无符号整数的乘积，并产生高达 66 位的结果。
对指数求和以确定“移位”的数量，但这实际上看起来更像是内存索引操作，以查找累加器中从右到左开始做加法的位置。
看起来可能需要将进位位从精确累加器的最低位一直传播到最高位。
是有，但不需要花费线性时间；
硬件设计者很久以前就想出了如何“向前看”以更快地传播进位位，在时间上更像是总位数的对数。
而且累积可以在计算下一个乘积时同时发生。

相同的硬件足以计算任意长度的 unum 列表的精确总和（在g-layer中）。
从数学上讲，求和与一个向量所有值均为 1
的向量的点积相同，但总和运算需要一条单独的指令，以使计算机不必调用乘法器硬件来乘以
1。 如前所述，长累加器 这也正是扩展精度乘法所需要的。

13.4.2 原型中的融合点积和融合和
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

在原型中，g-layer融合点积为\ **fdotg**\ [ag,
bg]，其中ag和bg是等长的一般区间的列表。 u-layer版本是
**fdotu**\ [au,bu]，其中 au 和 bu 是 unum 或 ubound 的等长列表。
但请注意，\ **fdotu**
中的算术完全在暂存器中作为精确计算执行，并且仅在最后作为精确或不精确的
ubound 返回。 类似地，使用 **fsumg**\ [ag] 找到一般区间列表ag的g-layer
融合和，其u-layer等效项是\ **fsumu**\ [au]，其中 au 是 unum 或 ubound
的列表。 **fsumu** 函数同时也统计移动的位和移动的个数。

拥有\ *融合和*\ 是一种解放。 比如加法结合律表示对于数字 a、b 和 c，满足

.. math::


   (a + b) + c = a + (b + c)

此恒等式不适用于浮点数。 浮点数初等代数不及格。 例如，单精度中的
:math:`(-10^8 + 10^8) + 1 = 1`\ ，但 :math:`-10^8 + (10^8 + 1)`
错误地计算为 0。浮点运算 :math:`10^8 + 1` 会产生舍入错误，准确地返回
:math:`10^8 = 100000000`\ ，而不是 :math:`100000001`\ ，因为
后者不是单精度浮点数可以表示的数字。 Unum
在两个层面上遵守结合律：首先，当它出现在区间算术中时，有时被称为“*子结合律*”，因为等号被替换为“并非处处相等”的符号：

.. math::


   (\hat{a}\oplus\hat{b})\oplus\hat{c} \approx \hat{a}\oplus(\hat{b}\oplus\hat{c})

其次，g-layer求和对于其操作数的任何排序都会产生相同的结果，这是通过满足结合律得到的解放。
聪明的数值分析师不遗余力地设计了将浮点数相加的算法，以使舍入误差最小。
这一切都很好，但是做加法这样的简单行为不应该需要查找和编码复杂的方法！
拥有不受排序影响且受硬件支持的\ *融合和*\ 意味着无需思考。
它就是直接可用的。

作为一个如果以直接的方式完成可能不太顺利的求和示例，假设我们编写一个循环来查找从
1 到 100
的倒数平方和，也就是\ :math:`1 + \frac{1}{2^2} + \frac{1}{3^2} + \cdots + \frac{1}{100^2}`,
只使用\ :math:`2^3=8`\ bit
作为小数。（顺便说一句，求和从1加到\ :math:`\infty`\ 的结果是\ :math:`\frac{\pi^2}{6}=1.64493\cdots`\ ）

.. figure:: assets/image-20230627144147870.png

   image-20230627144147870

总和的限制比需要的要宽松得多； 它有 95 个 ULP 宽！
一些数值分析专家表示，提高准确性的方法是找到对总和进行分组的方法，使相加的数字接近相同的量级，你可以想象这需要多少编程。
相反，只需使用融合和将列表精确地添加到 g-layer中，仅在末尾转换为一个 ULP
宽的不精确值：

.. figure:: assets/image-20230627144515773.png

   image-20230627144515773

该代码更容易编写，更容易阅读，执行速度更快（因为每次添加时它不必在
g-layer和 u-layer之间来回），并且在此环境中尽可能准确（以最高精度的一个
ULP 宽）。 它在各个方面都获胜。 最重要的是，不需要数字专业知识。

13.4.3 并行计算的一致结果
~~~~~~~~~~~~~~~~~~~~~~~~~

.. figure:: assets/image-20230627144909325.png

   image-20230627144909325

..

   天河二号超级计算机是2014年计算机集群的代表。 它拥有超过 300
   万个处理器核心，能够在 9 微秒的启动延迟后以每秒约 50 Gbps/lane
   的速度通信。

.. raw:: html

   <table border="2">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightyellow">

浮点数关联律的缺乏阻碍了并行计算的使用。

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

当将顺序程序转换为并行运行时，我们经常需要对浮点数列表进行求和。
顺序程序将以这种方式添加四个元素

.. math::


   s=x_1+x_2+x_3+x_4

其实真正的意思是从左到右做加法

.. math::


   s=((x_1+x_2)+x_3)+x_4

如果并行求和，一个处理器可以同时求和
:math:`s = x_1 + x_2`\ ，另一个处理器可以同时求和
:math:`t = x_3 + x_4`\ ，然后可以通过将 :math:`s` 和 :math:`t`
相加来组合。 但这意味着总和计算为

.. math::


   s=(x_1+x_2)+(x_3+x_4)

而浮点数结果是不同的答案。
对于这种类型的差异，通常的反应是：“并行处理不起作用；它给出了错误的答案。
我要回到顺序执行的版本。”
或者，如果程序员有足够的决心，他或她将编写一个模仿并行操作顺序的顺序版本，这会创建看起来奇特的复杂代码。
我们已经知道 unum 消除了处理器内的问题，因为它们可以在 g-layer
内精确地求和。那 unum
对使用多个处理器求和时获得不同答案的问题提供任何帮助吗？

如果合并多个部分和，通常会得到与从左到右连续做加法结果不同的bound。
但是，除非代码中存在真正的错误，否则两种bound将始终相交。
这意味着程序员可以立即发现错误和精确信息丢失之间的区别。 Unum
有一个内置的“服务质量”度量，即答案中边bound界宽度的倒数；
这意味着提交给网络上的抽象机器的作业可以在各种硬件配置上运行。
机器越强大，bound就越严格，但是没有逻辑错误的 unum
程序总是会返回一定准确度的正确答案。
然而，\ *我们还可以比这个做得更好*\ 。

没有规定说 g-layer中的值不能在\ **处理器之间交换**\ 。
如果部分和以扩展精度形式交换（对于 {4, 5} 环境可能有两组 66 000
位），则总和\ *不会*\ 有差异，并且系统可以自由使用任意数量的处理器而不会造成结果差异。

如果将如此多的比特位发送到片外的想法听起来像是真正的能源浪费，并且需要花费太多时间，请考虑当前老式集群计算机的数字，如本节开头所示，使用消息传递来
协调并行性：由于建立链接的时间原因，交换尽可能小的消息需要大约\ **九微秒**\ 的延迟。
一旦建立链路，核心处理器之间的连接可以维持每秒约 50 Gbps 的速度。
按照这个速度，即使是必须以最大内部长度发送两个 g-layer
边界的最坏情况，在九微秒的设置之后也只需要不到\ **两微秒**\ ！
（我们很少需要传整个长累加器，因此通常会比这个少。）对于完美的、可重现的结果来说，这似乎是一个很小的代价。

正如 unum 以及 g-layer和 u-layer
之间的区分消除了不同计算机对实数计算产生神秘不同答案的现象一样，\ **它们也可以消除串行和并行计算之间无法解释的差异**\ 。

13.5 其他的融合操作
-------------------

13.5.1 不是所有成对的操作都应该融合起来
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

还有哪些其他算术运算对可以进行融合？
主要标准是，与执行单独操作相比，融合可以显着减少信息丢失，且可以利用我们现有的暂存器资源。例如融合除法-加法和加法-除法会增加硬件的复杂性，但通常带来的好处很少。
第二个考虑因素是一些融合运算允许使用较小的最大尺寸指数，因为只有暂存器需要处理非常大或非常小的数字。
下面的融合操作可以说是值得的

13.5.2 融合乘法
~~~~~~~~~~~~~~~

除非超出动态范围，否则乘法不像加法或减法那样容易导致灾难性的信息丢失。
我们可以定义“融合乘法”，但更有意义的是：列表中
n个数字的融合乘，类似于融合加的乘法。

即使 :math:`a \times b` 或 :math:`b \times c`
的中间计算在第二次乘法之前返回到 u-layer会落入
:math:`\pm(0、smallsubnormal)` 或 :math:`\pm(maxreal, \infty)`
区域，\ :math:`a \times b \times c` 也可能在动态范围内。
融合乘解决了这个问题。

想要融合乘的另一个原因是它遵循结合律：

.. math::


   (a \times b) \times c = a \times (b \times c).

硬件在计算融合乘积时应该做的第一件事是检查所有输入值是否存在异常，因为它们可能允许快速得出u-layer结果。
硬件应该做的第二件事就是简单地将所有指数相加；
如果它们落在环境的动态范围之外，则区域 :math:`\pm(0、smallsubnormal)` 或
:math:`\pm(maxreal, \infty)` 之一就是答案，同样不需要进行算术运算。
在这种情况下，与单独进行乘法相比，融合乘积实际上可以节省大量时间和能量。

在必须完成所有算术的其他情况下，当数字列表很长时，很容易想象会耗尽内存。
融合乘法的硬件需求不需要比我们已经拥有的更多，但在用于乘法的“可调扳手”组中，它可能会强制使用下一个尺寸，其中需要一些扩展的精度。
与所有 unum
乘法一样，硬件首先注意到要使用哪个工具：部分积的专用平行四边形、使用长累加器的扩展精度乘法，或者对非常大的数字有效的复杂例程。
用户应该期望融合乘积比单独乘法更慢且更耗能，就像选择更高精度的运算一样。
仅在少数可能超出动态范围的情况下使用融合乘法，可以使程序员不必将环境设置更改为更大的esizesize。

原型中g-layer对一般间隔列表ag的融合乘法函数是\ **fprodg**\ [ag],
u-layer的函数是\ **fprodu**\ [au].

要了解融合乘积为何有用，请尝试一个小环境 {2, 3}，其中 maxreal 仅为
510，并且小数域仅提供大约两位十进制的精度：

.. figure:: assets/image-20230627153729472.png

   image-20230627153729472

鉴于 0.02 被转换为不精确的 unum，乘积
:math:`400 \times 30 \times 0.02 = 240` 在 g-layer
中得到了相当好的求值：

.. figure:: assets/image-20230627153901919.png

   image-20230627153901919

与另外两种使用单独乘法的方式进行对比：

.. figure:: assets/image-20230627154044440.png

   image-20230627154044440

信息丢失可能是常见的在动态范围内的ULP宽度增加，或者如果中间的乘积落入
:math:`(maxreal、\infty)` 范围（如上述第二种情况），则信息丢失会很严重.

13.5.3 融合的加乘
~~~~~~~~~~~~~~~~~

第一眼看上去，这就像一个失败的选择。 在暂存器中精确计算
:math:`(a + b)\times c` 意味着将 a 和 b 精确相加，这需要与 EDP
相同的巨大累加器，然后将其相乘。 但算术分配律说

.. math::


   (a+b)\times c = (a \times c) + (b \times c)

右侧的表达式只是 (a, b) 与 (c, c) 的点积。 这意味着融合加乘只是 EDP
的一种特殊情况，并且比最精确的点积更容易计算，因为如果两个乘积的大小不同以致缩放后的位串不重叠，则可以跳过加法。（这种情况只需要设置
ubit
来指示在较大数字的小数中最后一位之后还有更多含有1的位。）相同的技巧可用于任何加法；
唯一的区别是 g-layer 中的乘积的小数比特串长度是u-layer中的两倍。

一般区间的原型函数是g-layer的 **famg**\ [ag, bg, cg] , u-layer中的
**famu**\ [au,bu, cu]。
与往常一样，u-layer版本会统计移动的位和移动的数字，以评估 unum
数学相对于浮点数学的成本。

顺便说一句，如果加法和乘法作为单独的 unum 运算完成，则 unum
算术遵循“次分配律”：

.. math::


   (au \oplus bu) \otimes cu \approx (au \otimes cu) \oplus (bu \otimes cu)

这不适用于浮点算术。 方程两边产生的 ubounds
总是重叠的，如果它们不相同，那么它们的交集就是加乘法的改进界限。
但通过融合加乘，总是会返回最佳可能的边界，而不必担心此类事情。

13.5.4 融合乘比率
~~~~~~~~~~~~~~~~~

代数学说
:math:`(a \times b) \div c = a \times (b \div c)`\ ，因此\ *融合除乘*\ 与\ *融合乘除*\ 是一样的。
对于浮点型表示，首先执行乘法始终是正确的做法，因为它始终可以在暂存器中精确完成，而除法通常会产生余数。

包含融合乘除法的原因是它有助于抓住获得精确结果的所有可能性。
例如，对于浮点数，\ :math:`(x \div 7) \times 7` 通常会产生与 x
不同的数字（由舍入误差引起），而对于nums，\ :math:`(xu \odot \hat{7}) \otimes \hat{7}`\ 通常会产生包含
:math:`xu` 但与 :math:`xu` 不同的不精确 ubound。
与这些数字进行融合乘除将准确返回 :math:`xu` ，不会丢失任何信息。

硬件实际上已经能用于做融合乘除法，因为暂存器中的乘法会产生精确的整数乘积。
除以分数只是意味着对整个整数乘积进行长除法，而不是首先剪掉超过最大小数大小的位。
当结果不精确时，单独乘法和除法的 ubound ULP
宽度通常是融合乘法除法宽度的两倍，因此融合形式有助于保留有关答案的信息。

很容易推广融合乘除法，而不违反任何关于计算序列可以在 g-layer
中保留多长时间的规则。 假设我们想要计算

.. math::


   x=\frac{m_1 \times m_2 \times \dots m_j}{n_1 \times n_2 \times \dots n_k}

g-layer中的乘法可以是精确的； 最终的长除法仅需要达到 u-layer
所能表达的极限。 将此称为\ *融合乘积比*\ 。
它包括融合乘除法和融合除乘法。 注意 j 和 k 是独立的；
分子和分母列表的长度不需要相同。

g-layer中一般区间列表numeratorsg 和denominatorsg
的融合乘积比的原型函数是 **fprodratiog**\ [numeratorsg, denominatorsg]。
u-layer 版本是 **fprodratiou**\ [numeratorsu,
denominatorsu]，它还计算移动的位数和数字个数。
作为它能有啥帮助的示例，请尝试在没有融合的情况下评估
:math:`(5 \times (3 \div 10))`\ ，其中我们故意进行不利分组，首先进行除法操作：

.. figure:: assets/image-20230627162005119.png

   image-20230627162005119

对应的融合操作保留了精确的结果

.. figure:: assets/image-20230627162044641.png

   image-20230627162044641

几个世纪前，一位名叫约翰·沃利斯 (John Wallis)
的英国数学家发现了一个奇怪的\ :math:`\pi` 公式（“沃利斯积”）。
它提供了一种方法来演示在分子和分母中进行大量乘法的融合乘积：

.. figure:: assets/image-20230627162218677.png

   image-20230627162218677

也就是分子中无限多对偶数整数的乘积，除以分母中无限多对错开的奇数整数对的乘积。(
顺便说一句，沃利斯是“:math:`\infty`”符号的发明者，尽管他对它的数学定义更像是
:math:`(maxreal, \infty)`\ ，而不是精确的无穷大。）

以下是融合乘积比率例程如何计算 Wallis 产品的前几项，以及初始因子 2：

.. figure:: assets/image-20230627162716094.png

   image-20230627162716094

环境设置为 {2, 4} 以演示使用此类融合操作的原因之一。 在 {2, 4}
环境中，maxreal 约为
512，因此动态范围足以表达上面显示的所有数字，但对于临时计算来说太小。
分子乘积为 832359628800，分母乘积为 273922023375，如果使用单独的 unum
运算进行计算，则需要更强大的指数字段（大小为 3 或更大）。
但融合计算工作得很好，并返回了尽可能准确的答案。 所有大整数都在 g
层中处理，它返回范围内的 u 层数作为最终比率。 计算中的平均 unum 大小为
13.5 位，这对于精确到小数点后五位的答案来说非常便宜！

大约需要沃利斯乘积的 n 项才能达到 :math:`\pi` 正确值的大约
1/n，因此我们不应该对缺乏收敛性感到太失望。
要点是任何长的有理数和整数的乘积序列都可以而且应该由融合乘积比率例程处理。
如果我们明确地向
g-layer请求帮助，则该任务不需要具有大指数的环境来处理中间计算结果。
此外，如果融合函数可以在 u-layer 中表达，则融合函数可以产生精确的结果。

13.5.5 融合范数、融合根点积和融合均值
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

最后三个融合函数不是原型的一部分，但在这里作为更全面的 unum
计算环境的建议提出。 这里的“范数”的意思是“平方和的平方根”。 它可以像坐标
(x、y)与原点的距离一样简单：

.. math::


   r = \sqrt{x^2+y^2}

或者它可能是数百万个平方数之和的平方根。
它是科学计算中最常见的表达方式之一。
也是担心超出数字世界定义边缘的另一个原因，因为数字在临时计算中会被平方。
取平方根的最后一步使动态范围接近输入值的范围。
如果计算机中唯一必须承受暂时太大或太小的指数负担的部分是
g-layer，则可以在 u 层中使用较小的 esizesize。

应仔细计算平方，并注意第 11.1 节中详述的问题。
求和是通过完整的累加器完成的，因此一切都是精确的整数算术，直到算平方根前。如果平方根不精确，只需与
u-layer中的 fsizemax 分数位所需的精度一样。

出于同样的原因，在将答案返回到 u-layer
之前，使用在末尾执行平方根的版本来扩展 EDP 点积将是有价值的。
对于许多几何计算，我们需要尽可能准确地知道\ :math:`\sqrt{a\cdot b}`\ ，其中a和b是向量。
融合平方根可以减少少量信息丢失，但它再次使我们不必在中间结果使用过大的指数大小。

最后，在对一组 n 个数字求和后，通常希望通过除以 n 来求出它们的平均值。
如果 n 很大，则在 g-layer 中使用除以 n
的融合均值同样可以消除对过大指数大小的需要，因为均值将与求和的输入值处于相同的动态范围内。

我们现在有足够的操作来测试 unum 计算环境的可行性。
我们需要回答的一些问题：

-  ubound 是否经常像传统间隔一样扩展，给出无用的大范围？
-  为了得到满意的答案，它们使用的位数比浮点数多还是少？
-  它们是否容易在经典测试问题上遇到与浮点数相同的陷阱？
-  它们比浮点数更容易使用还是更困难？

在将 unum 应用到经典计算物理问题（第 2
部分）之前，我们首先对它们进行一些“酸性测试”，这些问题是数学家多年来发明的，旨在暴露计算机数字的缺陷。
