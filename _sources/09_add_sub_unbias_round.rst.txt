
9 加减法和无偏差舍入的迷
========================

.. figure:: assets/image-20230620123711433.png

   image-20230620123711433

..

   1982 年，温哥华证券交易所建立了股票指数，初始值设为
   1000。尽管经济健康，但该指数在接下来的两年内稳步下降至 520。
   该指数是通过加减股票变化来更新的，使用舍入到小数点后三位十进制的浮点数，因此舍入误差会累积。
   如果根据实际股价重新计算股票指数，显示该指数实际上是 1098，而不是
   520。如果使用 unum 算法，近似值的累积会很明显被发现的。

9.1 重新学习加法表…对实数
-------------------------

原型使用“:math:`\oplus`”来代表ubound和unum的加法，所以计算“-3+7.5”用ubound就被记为“:math:`\hat{-3}\oplus\hat{7.5}`”。这有点像是bizarro
arithmetic，每一个数和每一个操作都被稍微改动了，提醒我们这是计算机的操作，跟纯粹数学的操作不一样的。

现在我们开始对unum和ubound做一些基本的算术，然后追踪用了多少bit并跟用IEEE浮点数做来比较使用的比特数。每个unum的比特数不同，所以原型中定了ubitsmoved和numbersmoved两个全局变量，可以在运行计算例程前清零。最简单的比较代价的方式是看ubitsmoved/numbermoved的比例，这告诉我们平均每个数消耗的比特数目。一个加法从存储中读入两个数，写出一个答案。所以加3到numbersmoved。而ubitsmoved计数器则加上所有输入输出的ubound比特数目（通过nbits函数得到）。

在一个真正的硬件系统中我们也许不太需要考虑测量数据搬移代价，但是我们需要实验数据回答以下问题

   在完整解决一个实际问题时候，unum比起float更省空间吗？

传统间隔算术做加法是很直接的。[a, b]和[c, d]相加结果是[a+c,
b+d]。a+b向\ :math:`-\infty`\ 舍入，而b+d向\ :math:`+\infty`\ 舍入。但是ubound更复杂些，需要处理端点开/闭，动态指数小数长度，和结果超出最大可表示数maxreal等问题。比如\ :math:`(-\infty, 0)`\ 加上\ :math:`\infty`\ ，正确的答案是\ :math:`\infty`.
因为开的端点\ :math:`-\infty`\ 表示的是实际上有限的一个数，加上\ :math:`\infty`\ 总是\ :math:`\infty`\ 。

ubound加法需要两张表，一张对左端点,使用“[x”或“(x”表示，一张对右端点,
使用“x]”或“x)”表示。大括号用在一些非常奇怪的表示上。

这包括了所有可能。每个实现unum计算的人都需要深思一下表中的一些情况，例如

-  “:math:`(-\infty \oplus [\infty = [\infty`” 和
   “:math:`-\infty] \oplus \infty ）= -\infty]`” :
   包含的无穷赢过不包含的无穷
-  “:math:`( \infty`” 和
   “:math:`-\infty)`”不存在，不包含在表中。注意这是开区间情况，闭区间可以有\ :math:`[\infty`,
   当然一定配\ :math:`\infty]`\ ，同样的也可以有\ :math:`[-\infty, -\infty]`
-  如果“:math:`[x \oplus [y`”结果超出了maxreal,
   那么结果是“:math:`(maxreal`” 而不是“:math:`[maxreal`”
-  如果“:math:`x] \oplus y]`”结果超出了maxreal,
   那么结果是“:math:`\infty)`”
-  类似的规则对-maxreal
-  即使是精确数的闭区间端点，在g-layer做了计算后，转换回u-layer的时候还是有可能变成不精确的开区间端点。只要结果落在u-layer的一个ulp的区间。（前面maxreal其实就是一个例子）

IEEE标准不能很好地处理这些微妙的无穷的情况，而只是简单地产生一个NaN的结果。由于溢出在IEEE标准中变成了无穷，float实际上在结果中引入了无穷大的误差。unum纠正了这个错误，能表示一个数过于大以至于不能表示，但是是有限的。唯一产生NaN的情况是精确的\ :math:`–\infty`\ 加精确的\ :math:`+\infty`\ ，这个是无解的终极拉锯战。

下面是表了，罩住了整个实数线和无穷。x,
y是精确可表示的u-layer数，如果结果是加法的和，用黑色。异常则使用洋红色。同样的端点的开闭是or上两个inexact标记。

首先是g-layer加左端点的表

.. figure:: assets/image-20230620140839266.png

   image-20230620140839266

其次是g-layer加右端点的表

.. figure:: assets/image-20230620140903172.png

   image-20230620140903172

解包的unum格式比较容易看出在表中的位置。比如
“:math:`-\infty]`”就是\ :math:`b_{63}`\ (小于0) 与上
:math:`b_{61}`\ (无穷) 与上 非\ :math:`b_9` (不精确)

返回到u-layer是很简单，除了要主要那些包含有[x+y 和
x+y]的情况。如果x+y的几个不是个可表示的精确值，那么需要换为包含它的非精确值，从而改变为开区间。这包含当x+y小于-maxreal或是大于maxreal是，端点就变成区间\ :math:`(-\infty, -maxreal)`\ 和\ :math:`(maxreal, \infty)`.附录C.9有加法的代码，也是根据上面的表，gbound处理然后转回ubound.
还自动检查unify是否可以做到无损压缩，如果可以就返回压缩的模式。

原型用函数negateu来将一个ubound去负数。ubound的减法\ :math:`\ominus`\ 就是把减法换成加负值。就是在g-layer中做\ :math:`x-y=x+(-y)`\ ，最后再讲结果转回会u-layer。

9.1.1 例子和测试数据搬移量
~~~~~~~~~~~~~~~~~~~~~~~~~~

尝试一个含无穷的例子，有开和闭区间。为了清晰，我们把输入表示为间隔，再转换成ubound来计算。所以\ :math:`(-\infty, 4) \oplus (maxreal, \infty]`\ 的结果是\ :math:`(-\infty, \infty]`

.. figure:: assets/image-20230620151118566.png

   image-20230620151118566

左边变为开区间

.. figure:: assets/image-20230620151241275.png

   image-20230620151241275

无穷减无穷是NaN

.. figure:: assets/image-20230620151427862.png

   image-20230620151427862

尝试在一个{3，4}环境中做(2.25,
2.5)加9，并且记录数据搬移量。加ubitmask是表示2.25右边一个ULP的区间，长度0.25.
在u-layer, 这些数的表示如下

.. figure:: assets/image-20230620151810117.png

   image-20230620151810117

两个unum分别占用了13和15bit，我们还需要一比特记录是否是一部分还是两部分的ubound。ubound占用14和16bit。重置计数器，看结果

.. figure:: assets/image-20230620152202909.png

   image-20230620152202909

结果自动被扩展为18bit
ubound。使用原型定义的函数汇报数据搬移量，得到如下表报告

.. figure:: assets/image-20230620152426725.png

   image-20230620152426725

相同符合两个数相加通常会增加小数位数，或是指数位（未必，因为和的小数有可能reduce
to lower
term?）。特别是对于指数相差过大的数，比如我们用手工做做\ :math:`2.0\times 10^{14}`\ 和17的加法,
想得到的结果是精确的，你就需要写下所有的数字： 200000000000017

减法，或者加两个符合不同的数，有可能导致小数消除左边有效位，这就减少了需要的指数位数。所以减法有时候得到结果的更短。

9.1.2 三维可视化ubound的加法
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

还记得我们把一个通常的间隔用实数线上的粗的线段来表示，圆的边角代表开区间，方的代表闭区间。现在我们有两个间隔了，用同样的方式来表示为一个二维的块。例如下图是代表x是[-1,
5)， y是(-2, 4]:

.. figure:: assets/image-20230620154932159.png

   image-20230620154932159

注意边角代表了开闭空间，只有一个角是完全方的，就是backview中(x=-1,
y=4的位置)，其他都都是圆角。加法的结果表示为一个平面但最终投影在实线上，两边都是开区间。

.. figure:: assets/image-20230620155456424.png

   image-20230620155456424

9.1.3 unum加减法的硬件实现
~~~~~~~~~~~~~~~~~~~~~~~~~~

unum
端点的加法和减法非常类似于传统浮点数的加法和减法，已经有很多文献都写过了。
这两种情况下一旦处理了异常，确定了隐藏位，就可以排列二进制小数点，然后像做十进制加法样一样从右到左按位做二进制加法。
由于使用不精确的 unums 或 ubounds
将需要两个端点对，因此设计一对可以并行执行的加/减单元是有意义的。

还有个重要的不同是关于舍入的。当结果的小数超出了可以容纳的量，
IEEE的浮点要求一个复杂的硬件选择一个不正确的浮点值来代表答案，有4种可以选择的舍入模式。而unum就简单地设置好ubit表明在最后一个比特后面还有更多的比特作为答案。这个做法和解包unum格式的预译码的异常位和隐藏位，表明unum的每一个端点的加减执行都会快些且花费更少的功耗。这有利与补偿使用两个部分的ubound需要做两次加减法。

假设一个浮点数有 p 个小数位。 每当指数相差超过 p
时，它表示当二进制小数点排列时分数之间不会重叠，因此逻辑可以采取捷径来计算如何舍入数字。
unum对于同样的数可能存储少于 p 位，但也有支持大于 p 的最大
fsize，可以在大部分时间捕获正确答案。

比如这是在{3,4}环境中的两个unum

.. figure:: assets/image-20230620161742352.png

   image-20230620161742352

指数相差12 (:math:`2^{-8}对` :math:`2^4`)。如果是两个IEEE
16比特浮点相加，硬件检测到指数差已经超过小数10比特的长度，那么就直接丢弃掉小的数，回答是\ :math:`30+\frac{1}{256}=30`
。unum硬件检测到指数的差异跟最大的小数长度\ :math:`2^{fsizesize}=16`,
就直接提升精度来完成这个加法

.. figure:: assets/image-20230620162524967.png

   image-20230620162524967

如果我们检测到指数差异超过了\ :math:`2^{fsizesize}`,就可以采用捷径，直接标注数据是不精确的。比如\ :math:`\hat{1000}\oplus\hat{\frac{1}{256}}`
就可以快速地给出一个正确的不精确结果

.. figure:: assets/image-20230620162913589.png

   image-20230620162913589

9.2 渐长的积垢（creeping crud）和无偏舍入的神话
-----------------------------------------------

IEEE
二进制浮点数中有四种“舍入模式”：向上舍入、向下舍入、向零舍入和最接近偶数舍入。
它们的同义词分别是：向无穷大舍入、向负无穷大舍入、截断舍入和无偏舍入。

如果我们可视化向上舍入，三角形左边是精确值，经过一个计算step后，真正的解包被替换为向正无穷靠近1个ulp间隔的精确值。用十进制数学舍入\ :math:`13 \div 6=2.1666….`
会向上舍入到3.如果我们是13除以-6会舍入到-2.如果我们的舍入误差是随机的，平均每一个step误差增加0.5ULP。

.. figure:: assets/image-20230620163505196.png

   image-20230620163505196

向下舍入就是前面说的温哥华证券交易所使用的模式。他们使用3位十进制数值，但是每次更新指数永远向下舍入。误差图就是上图的垂直镜像。

.. figure:: assets/image-20230620203457608.png

   image-20230620203457608

一些应用，比如信号处理，或是简单的计算机图形学，舍入模式没有看上去的那么糟糕，原因是每个数据item只有少量的数学运算操作，所以舍入误差不会累积起来。但是对于温哥华证券交易所，下图是累积误差的样子，假设每次舍入都是统计学独立的。

.. figure:: assets/image-20230620204117762.png

   image-20230620204117762

向零舍入舍入比上面两个模式容错性强，因为计算有相同的几率是正的或是负的误差。比如两个向量的点积\ :math:`a_1b_1+a_2b_2+\cdots+a_nb_n`.
如果a和b的元素都以相同几率为正或负，那么舍入有一半是向上，一半是向下。

最常用的舍入模式是无偏差舍入，就是替换正确答案为半个ULP以内的浮点数。如果是平局（正好都半个ULP），那么选择最近的偶数。无偏舍入需要额外的硬件，和执行时间。但是结果看上去更好看些。

.. figure:: assets/image-20230620204805829.png

   image-20230620204805829

无偏舍入可以把平均误差减少到0.5到0.25个ULP之间。但是可以在任意方向。这就把我们带到了统计学家所说的随机运动问题。假设你多次抛掷一枚硬币，如果是正面你往前一步，反之后退一步。经过n次抛掷，你离开起点多少步。我们期望抛掷得到正面的平均数目是n/2,
但是会有些偏差，近似是一个钟形曲线，如下图

.. figure:: assets/image-20230620205805573.png

   image-20230620205805573

偏差是抛掷数量的平方根。

所以推论是无偏差舍入的累积误差在很多次计算累积后都是可以容忍的。

.. figure:: assets/image-20230620210101442.png

   image-20230620210101442

即使我们做1
billion（\ :math:`10^9`\ ）个加法，推导出来的ULP数目通常在\ :math:`\pm\sqrt{10^9}`\ 个0.25ULP，这大概是7906个ULP，如果是用单精度累积，一个ULP是\ :math:`\frac{1}{8388608}`,
所以我们累积误差在\ :math:`\frac{7906}{8388608}`\ ，或者说是正确答案的0.001。

你接受这个说法吗？显然看上去是合理的推导。单精度可以表示高达\ :math:`10^{38}`\ 的数，而且有足够的小数来表达\ :math:`10^9`\ 大小的精确整数。

随机运动可以保护我们避免累积误差，对吗？

一点也不。 下面是一个简单的C程序试图累加1 billion次1

.. raw:: latex

   \diilbookstyleinputcell

.. code:: c

   #include < stdio.h >
   float sumtester () {
       float sum; int i;
       sum = 0.0;
       for (i = 0; i < 1000000000; i++) {
           sum = sum + 1.0;
       }
       printf (“%f\n”, sum);
   }

你能得到的结果是（用IEEE单精度浮点float）

16 777 216

结果小了60倍。并不是单精度浮点不能表示累加值那么大的数，那到底哪里出错了？

错误发生在假设舍入误差是独立的向上或是向下。舍入误差通常不是独立的，在上面求和程序中，他们一直是一个方向，向下。当和达到\ :math:`2^{24}=16777216`\ 后，一个ULP的宽度大于了1，所以加1什么都不能改变。最接近偶数舍入一直不停的把正确答案16
777 217舍入到16 777 216。

这样一个在长时间的计算中缓慢累积舍入误差的现象有一个别名叫“creeping
crud”
（渐长的积垢），但是如这个例子显示的那样，误差不一定总是像爬行一样累积的，有时候也是跑步一样迅速增长的。无偏舍入假的神话是基于设舍入误差是独立且随机地向上和向下的。\ **这个假设并没有任何逻辑的基础**,
例子程序显示了即便是简单的程序也不支持这个假设。

计算中一个常用的方法是蒙特卡洛仿真方法，就是通常要求累加随机数经过某函数变换后的值。如果你选择1
billion的0到1间的随机数，统计学说结果应该是0.5 billion.

试试看用单精度是怎么样的，结果还是16 777 216， 一点不接近500 000 000.
蒙特卡罗方法的一种应用是对股票投资组合的财务价值进行建模，并确定哪些股票被高估或低估。
想象一下，在就一项重大投资向客户提供建议时，由于无形的舍入误差而出现八倍偏差的后果!

9.3 自动精度控制和简单的 unum 数学测试
--------------------------------------

现在我们可以做 unum加法了，我们可以试验 unum 处理累积误差挑战的能力。
如果我们在前面的示例中使用可以模仿 IEEE 单精度的 {3, 5}
环境，这还不是一场公平的战斗。 unum
只需使用最小指数大小并根据需要调整小数来计算确切的答案，以表示每个整数加法而不进行四舍五入（毕竟小数部分可以高达32b,
而float只有24b）。 真正的问题是当 unums
必须将结果标记为不准确时会发生什么。 这比四舍五入好吗？

要研究该问题，请使用精度非常低的 {3, 3} 环境来放大该问题。 在 {3, 3}
环境中，可以表示最大为 512 的整数，但请注意我们将 1 的 unum 添加到 512
的 unum 会发生什么

.. figure:: assets/image-20230621084439329.png

   image-20230621084439329

这比浮点数更好； 相同精度的浮点数将准确地返回数字 512。
Unum至少警告我们，我们有一个“渐长的积垢”问题。 范围 (512,
1952)非常大，这表明 unum 可能会遇到区间运算的问题。 然而，由于 unum
环境记录数字本身的准确性，因此它们提供了使用以下规则自动检测、分析和纠正准确性损失的可能性

.. raw:: html

   <table border="2">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightblue">

如果结果包含 maxreal 或 –smallsubnormal 作为其下限，或者 –maxreal
或smallsubnormal 作为其上限，则计算环境需要更大的 esizesize。
如果相对宽度大于设定的公差，则计算需要更大的fsizesize.

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

由于无法准确表示 513，因此我们得到一个包含 513 的开区间。
这看起来像传统的区间算术，但 ubound 仅使用 22 位而不是 128
位，并且表达出了总和不等于 512 也不等于 514
的事实，而是严格介于这些边界之间的数字。 尝试再加1，ULP宽度扩展为4；
它仍然可以用 20 位 unum 有效地表达，但精度已下降到大约两位十进制小数：

.. figure:: assets/image-20230621092307613.png

   image-20230621092307613

了解了准确性如何丢失后，这里给出 10^9 求和问题的“比例模型”。这次只是循环
1000次，足以强制使用不精确的 unum：

.. figure:: assets/image-20230621092904911.png

   image-20230621092904911

以上缺点都可以由计算系统自动跟踪和纠正。 第一种情况的自动测试很容易；
如前所述，如果结果对于动态范围而言太小或太大，\ **needmoreexpQ**
函数将返回 True。 例如，给 maxreal/2 加 1 不会超出环境的范围。

.. figure:: assets/image-20230621095943725.png

   image-20230621095943725

但是将 1 加到 maxreal 会，因为表示和的唯一方法是使用开区间
:math:`(maxreal，\infty)`\ 。

.. figure:: assets/image-20230621101239670.png

   image-20230621101239670

相对位宽如果是0.05就基本对应一个十进制数的精度。间隔(10,
11)达到了一个十进制精度，因为\ :math:`\frac{11-10}{11+10}=0.047`
没有超过0.05。而间隔(9,
10)就达不到这个分界点，因为\ :math:`\frac{10-9}{10+9}=0.052`, 略超过了。

计算 ubound u 的相对宽度的原型函数是 **relwidth**\ [u]。
理想情况下，计算机系统可以选择使用内置硬件计算相对宽度，从而监控每个计算而不减慢计算速度。
然后可以自动生成最佳环境设置的指导，并且程序员可以将它们明确地放置在源代码中。

对于结果的间隔“太大”问题，我们可以通过多种方式测量间隔的相对宽度。
以下方法可以很好地处理异常情况。 如果 g 是一般区间，其中 glo 是下限，ghi
是上限（我们忽略端点是开还是闭），那么相对宽度的一种定义是

.. math::


   \text { Relative width of } g= \begin{cases}
   \infty & \text { if } g \text { is NaN, } \\ 
   1 & \text { if }\left|g_{\mathrm{lo}}\right|=\infty \text { or } \left|g_{\mathrm{hi}}\right|=\infty, \\ 
   0 & \text { if }\left|g_{\mathrm{lo}}\right|=0 \text { and }\left|g_{\mathrm{hi}}\right|=0 \\ 
   \frac{\left|g_{\mathrm{hi}}-g_{\mathrm{lo}}\right|}{\left|g_{\mathrm{lo}}\right|+\left|g_{\mathrm{hi}}\right|} & \text{otherwise.}
   \end{cases}

如果 g 表示 NaN，则相对宽度被视为无限大。 如果 g
有无限大的端点，则相对宽度为 1。如果端点符号相反，底部实数的比率也将为
1。
（如果我们无法判断一个数字是正数还是负数，那么我们真的对它了解不多。）

回想一下关于准确性的“要求和让步”讨论（第 5.4.2 节）。
应该允许计算机用户提出要求，例如“我的结果需要四位小数的精确度”；
这也是一种让步，因为这意味着计算机可以通过不计算超过四位小数的精度来节省能量和时间。
但计算机用户也不应该指定计算自始至终都以一定的精度进行，因为这把手段当成目的了。
正如计算机用户可以使用 **smartunify**
设置压缩数字的策略一样，用户可以设置环境变量 **relwidthtolerance**
来指定答案所需的准确性。 **needmorefracQ**
函数然后使用该容差来检测计算是否需要更大的 fsizesize。
相对宽度容差还设置了 fsizesize
的下限，因为必须至少有足够的分数位来表达所需的精度。 将
**relwidthtolerance** 设置为 0.005 表示我们想要两位小数的精度，这在 {3,
3} 环境中是可能的：

.. figure:: assets/image-20230621132754304.png

   image-20230621132754304

显然[10, 11]只有一位精度，需要更多bit

.. figure:: assets/image-20230621132851277.png

   image-20230621132851277

而间隔(500,
504)在{3，3}环境中只有一个ULP宽度，相对宽度约0.004，所以无需提升精度。

.. figure:: assets/image-20230621133045237.png

   image-20230621133045237

这种方法的流程图如下所示，其中蓝色显示的部分可以由程序员请求或自动执行。
该策略与用于保护长时间运行的超级计算任务免受硬件故障影响的检查点重启方法非常相似，这也可以在应用程序级别或由操作系统自动完成。
使用这些工具，我们将再次尝试求和，但让计算机自动管理精度和动态范围。
我们可以等待最终的总和，然后让计算机检查是否需要更多的指数或分数，或者我们可以全程监控计算，并在检测到需要提升精度时立即重新启动。
连续监控消除了继续进行明显“偏离轨道”的计算所浪费的时间。

.. figure:: assets/image-20230621144551097.png

   image-20230621144551097

下面是一个软件实现此类监控的程序，我们首先以 {2, 2}
环境开始，让计算机决定是否需要更多位。
每当计算机检测到环境需要提升时，一些老式的“跳转”语句就会重新开始计算。
这些语句按相应的流程图颜色进行颜色编码，自动监控显示为蓝色。

.. figure:: assets/image-20230621144951071.png

   image-20230621144951071

答案是精确的了，那目前到了什么样的环境呢？

.. figure:: assets/image-20230621145042415.png

   image-20230621145042415

由于我们只要求两位小数的精度，relwidthtolerance 为 0.005，因此 [991,
1010] 中包含的任何 ubound 的相对宽度测试都将通过。
当期望一个完全准确的结果是合理的，就像这里一样，程序员可以将
relwidthtolerance 设置为零。

这个流程是这样进行的：初始设置的{2，2}环境只允许最大4个指数位和4个小数位。和最高不超过32.
当到了后再加一就得到不精确数，范围在(32, 34).
计算其相对宽度是\ :math:`\frac{1}{33}`
显然是大于\ :math:`0.005=\frac{1}{200}`\ 。所以环境就自动提升到{2,3},
累加又重新开始，稍微浪费了一些计算。

第二次尝试的时候，加法结果超过了maxreal, 在{2，3}环境中是510.
所以再加1的时候就发现结果落在\ :math:`(510, \infty)`
这说明需要更多的指数。于是提升环境到{3, 3}，再次重新启动计算。

第三次尝试，当加法的和达到512这个精确值，接着就是不精确了，
ULP宽度开始逐渐累积：

512, (512，514), (512, 516), (512, 518)

这时候(512,
518)相对宽度大约是0.0058，超过门限，通过了\ **needmorefracQ**\ 测试，环境提升到{3,
4}. 这次可以一直做到最后得到的是精确的答案。

这个例子说明了一些数值分析可以被自动化，如果能让精度的丢失可以被看见。
