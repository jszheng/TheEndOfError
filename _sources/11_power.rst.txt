
11 求幂
=======

.. figure:: assets/image-20230625084059227.png

   image-20230625084059227

..

   在10.1节有做一个三维的图来显示乘法\ :math:`z=x\times y`
   的鞍形面。求幂函数\ :math:`z=x^y`\ 也是类似的鞍形面，上图用等高线图来显示。红色的角是上升的而蓝色是下降的。计算这个函数意味着要穿越异常情况的雷区，并面临以前未解决的数学难题。

11.1 平方
---------

与四种基本算术运算相比，找到 :math:`x` 和 :math:`y` 的通用幂函数
:math:`x^y` 是一个需要巨大努力的跳跃。
我们先从一个非常柔和的抛掷开始本章，创建 :math:`x^2`
的例程，因为平方是一种常见的操作。
但是即使这个简单的任务也带来了挑战，我们将在第 2
部分中更详细地讨论这一挑战。为什么不通过将 x 乘以自身来计算 x 的平方呢？

假设\ :math:`u`\ 是表征\ :math:`[-1, 2)`\ 的一个unum。这里说明为什么我们不简单第将\ :math:`u\otimes u`\ 来计算\ :math:`u`\ 的平方。平方的结果应该是\ :math:`[0, 4]`,
但是不动脑子地用乘法就会丢失两个数是相同的这个信息，结果产生了更宽松的(尽管也是正确的)一个范围\ :math:`(-2, 4]`
。

.. figure:: assets/image-20230625091914553.png

   image-20230625091914553

对数字进行平方永远不会产生任何负数，但乘法例程会产生的这样的结果结果，因为它错误地假设其输入值是独立的。
因此，平方代码需要注意跨越零的范围。 在精心制作的 unum
环境中，写入“:math:`x \otimes x`”应该会触发错误并向用户询问“您的意思是对
x 进行平方吗？”

用乘法还会产生错误的边界，比如$(-2, 2]的平方是[0, 4], 而不是[0, 4).
闭边界点“赢了”开边界点。

原型中，
g-layer函数是\ **squareg**\ [g]，u-layer版本是\ **squareu**\ [u]。代码在附录C.14.
下面是一个\ **squareg**\ 的范例

.. figure:: assets/image-20230625094700076.png

   image-20230625094700076

u-layer中\ **squareu**\ [u]的参数u是unum或是ubound，它还统计移动的个数和移动的比特位数；对于一元运算（具有一个输入的运算），移动的个数增加
2（一进一出），移动的比特位数是输入和输出中位的总和。

.. figure:: assets/image-20230625095112426.png

   image-20230625095112426

.. raw:: html

   <table border="2">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightgray">

读者的练习对于区间的立方函数应该用什么样的算法？

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

平方函数适用于所有实数和无穷大。 硬件需求并不比乘法更大。 如果我们使用
:math:`x` 的更高整数幂，例如 :math:`x^3` 、 :math:`x^4`
等，我们通常需要扩展精度乘法器，甚至是真正大的乘法器。
在我们讨论之前，考虑另一个非常常见的幂函数：\ :math:`x^{1/2}`\ ，\ :math:`x`
的平方根。

11.2 平方根
-----------

不精确的平方根是无理数； 它们不能表示为两个整数 p/q 的比率。
然而，它们并不是超越数，这听起来像是只有数学家才会关心的区别。
平方根是代数数，定义为代数方程（具有有理系数的多项式）的根的数字。
在一个 ULP 内计算代数数很容易，因为有很多快速方法可以找到代数方程的根。
对于平方根，有一些技术可以使每次迭代的正确位数加倍。
在硬件中计算平方根实际上并不比计算数字的倒数更难。
这就是为什么非数学家可能关心代数数和超越数之间的区别：\ **速度**\ 。

如果用于负数，平方根函数将返回 NaN，因为我们将计算限制为实数。
然而，平方根允许精确的“负零”起作用，而不是将结果声明为虚数，因为如果值恰好为零，则符号位将被忽略。
不过，不精确的负零总是会产生虚数结果，因为它包含严格小于零的数字。
因此，对于这些情况我们必须返回 NaN。 解包的 unum
格式使得检查触发异常的值变得简单快捷。

顺便提一下，IEEE标准规定负零的平方根应该是……\ *负零*\ 。
他们到底在想什么啊？？ 那是伯克利，而且是 20 世纪 80
年代，所以可能涉及到一些受管制的物质（大麻吗？）。 Unum
数学对于精确浮点数零时是会忽略符号的。

原型中g-layer的平方根函数是\ **sqrtg**\ [g],
参数g是\ *通用区间*\ 。u-layer的对应函数是\ **sqrtu**\ [u]，u是ubound。试一下求\ :math:`(1, \frac{25}{16}]`
的平方根，开区间端点还是保持开区间，闭区间端点是精确数，其平方根也是精确数，所以也保持闭区间。跟以前一样，端点1做为开端点的方式是设置ubit（也就是加上\ **ubitmask**\ 到unum位串上）。\ :math:`(1, \frac{25}{16}]`
的平方根应该是\ :math:`(1, \frac{5}{4}]` :

.. figure:: assets/image-20230625102455563.png

   image-20230625102455563

*通用区间*\ 求平方根很容易，因为该函数是单调递增的。
这意味着只需评估每个端点的平方根，如上例所示；
它保留了小于、大于的顺序。 该性质不适用于平方函数，这导致了复杂性。

大多数平方根都是无法用精确浮点数表示的数字，因此就像其他所有运算一样，我们创建一个包含真实值的开区间。
如果端点闭合且平方根准确，则端点保持闭合状态。 否则，ubound
算术会找到包含平方根的最小可能 ULP，并使用 unum 来包含该端点处的正确值。

在下面的示例中，我们显示了底层的 unum
机制，以显示左端点如何精确且紧凑（除了 utag
之外仅有三位），而值为\ :math:`\sqrt{3}`
的端点则需要所有可用的小数位并被标记为不精确。

.. figure:: assets/image-20230625103316847.png

   image-20230625103316847

3的平方根是 1.7320508…，因此上限精确到小数点后五位以上。
如果我们对这个结果求平方，我们将得到一个比我们开始时的 [1, 3]
范围稍大的范围。

.. figure:: assets/image-20230625103636363.png

   image-20230625103636363

注意高端是开的，正确的区间[1, 3]包含在其中。

.. raw:: html

   <table border="2">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightgray">

读者的练习unum
{2,2}环境所有的非负的准确值都列在4.10一节，有多少是有准确的平方根值的？

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

除了异常值之外，ubounds 表示的端点就像浮点数，是\ :math:`f \times 2^e`
形式的数字，其中 f 是区间 :math:`[1, 2)` 中的小数。
请注意，我们总可以通过让 f 位于区间 :math:`[1, 4)` 中, 来使 :math:`e`
成为偶数。 因此，如果硬件发现指数是偶数，则会计算
:math:`f \times 2^{e/2}`\ ； 如果指数为奇数，则计算
:math:`\sqrt{2 f} 2^{(e-1)/2}`\ ，因此指数非常容易计算并且始终可表示。
unum 与浮点平方根运算的不同之处仅在于 unum
自动最小化用于表示指数的位数。

11.3 嵌套的平方根和“ULP跨接”
----------------------------

这看上去对于讨论\ :math:`x^y`\ 是一个奇怪的方向。后面的原因是我们想讨论\ :math:`y=\frac{1}{4}, \frac{1}{8}, \frac{1}{16} \cdots`
幂次作为对于下一步使得\ :math:`x^y`\ 成为通用的函数。

由于平方根是一个表现良好的运算，我们可以用它来求
:math:`x^{\frac{1}{4}}=\sqrt{\sqrt{x}}`
，无论是作为一个精确的数字还是包含它的最小 ULP 吗？
答案是肯定的，如果您留意“ULP 跨接”并在其发生时予以纠正。
当然，第一个平方根可能会产生不精确的 unum。
然后，第二个平方根分别处理每个端点，这些端点的平方根可能是不同的不精确
unum，因为区间答案跨越一个精确值，而不是位于相邻 unum 之间的开区间。
信息损失可能会随着每个平方根而累积。

幸运的是，这个问题很容易解决，因为数字的平方可以在scratchpad中准确完成。
下面是在 {3, 3} 环境中的例子，我们尝试通过两次平方根来找到
:math:`266^{1/4}` 的答案

.. figure:: assets/image-20230625223217640.png

   image-20230625223217640

结果有两个ULP的宽度，因为第二次求平方根跨越了精确值\ :math:`\frac{258}{64}`\ 。但是\ **他们中只有一个才是正确的**\ 。所以吧端点和跨越点都提升做4次方来（两次平方）来检查（事实上我们只需要做中间点的，这里列出三个值便于说明）

.. figure:: assets/image-20230625223848393.png

   image-20230625223848393

啊哈，可以丢弃低部分的ULP，就是从\ :math:`\frac{257}{64}`\ 到\ :math:`\frac{258}{64}`,
因为他们中间不含有266.
所以unum结果是\ :math:`(\frac{258}{64}, \frac{259}{64})`

这个技术可以很容易地推广到嵌入的平方根

.. figure:: assets/image-20230625224255546.png

   image-20230625224255546

当任何时候发现根跨越了精确值，所以有两个ULP，都可以通过平方返回看哪一部分是正确值，然后继续。所以我们现在求
:math:`x^y` 的方法是“只要 y 是 2 的整数次幂”。 对于 2
的正幂，进行嵌套平方。 对于 2 的负幂，进行嵌套平方根，同时修剪“坏 ULP”。
如果指数为负数，只需计算其绝对值，最后取倒数即可。

11.4 对暂存器征税：整数的整数幂
-------------------------------

它被称为“高能power”函数是有原因的。
仅仅因为表达式易于记录，并不意味着它易于计算。 阶乘函数
:math:`n!= 1 \times 2 \times \cdots \times n` 就是一个很好的例子；
即使对于低至 n = 70 的数字，n! 比googol还大。 googol
也很容易用五个字符写下来：\ :math:`10^{100}`\ 。幂函数与
:math:`+ – \times \div` 属于完全不同的类别；
它很容易产生大量的工作才能计算到最高精度。 那需要的暂存器必须有多大呢？

它的位数很多，但并不像乍看起来那么糟糕，因为比例因子（指数）的单独存储意味着我们只处理由分数位表示的整数。
为了将其简化为足够小的数字以便于掌握，假设 unum 环境为 {2,
2}，因此最多有 :math:`2^2 = 4` 位来保存分数。 使用隐藏位，分数表示 0 到
31 的整数，按 2 的幂缩放。如果我们需要精确表达整数，暂存器需要保存大到
:math:`31^31` 的整数。 这可能看起来很可怕，但它最多只需要 155 位。 表示
31 需要 5 位，因此 :math:`31^2` 需要 10 位，\ :math:`31^3` 需要 15
位，依此类推，因此 :math:`31^31` 最多需要 :math:`5 \times 31 = 155` 位

如果我们构建一个具有直接硬件支持的 unum 环境，最高可达 {4, 5}
的环境，则最大小数长度加上隐藏位的长度为 33 位。 分数位表示的整数范围为
0 到 :math:`2^{33} - 1`\ ，或 0 到 8 589 934
591。最大的整数幂将需要（最多）这么多位来存储：

.. math::


   33 \times 8589934591 = 283467841503 \text{ bits }

更通常的说法是，大约 33 GB。 在2014
年，这么大的存储空间是介于便携式计算机和服务器的主内存大小之间。

所以这是一个很大的数字，但这样的硬件是存在的。
当前一代微处理器只需不到一秒的时间即可读取或写入这么多外部数据，按照人类标准来说已经足够快了，但比加法或乘法慢十亿倍。
如果我们想要与四种算术运算具有相同的绝对精度标准，那么一般 x 和 y
的幂函数 :math:`x^y` 就不是我们应该随意要求的运算。

现在我们知道我们面临的是什么，尝试计算一个小环境的 :math:`x^y` 。

11.5 低精度 xy 的计算练习
-------------------------

我们可以在{2,
2}环境中精确表示数据\ :math:`x=17`\ 和\ :math:`y=\frac{3}{8}`.试着计算\ :math:`x^y=17^{\frac{3}{8}}`.
修改表示\ :math:`17^{\frac{3}{8}}=(17^3)^{\frac{1}{8}}`.
在暂存区中几次乘法可以得到17的三次方，然后用12.4节描述的嵌套平方根来做\ :math:`\frac{1}{8}`,.

数字 17 占用 5 位，因此 :math:`17^3` = 4913 在暂存器中最多需要 15 位。
这是一个足够小的位数，我们实际上可以查看 4913 的二进制字符串：

.. figure:: assets/image-20230626162320696.png

   image-20230626162320696

对于平方根，我们需要指数为偶数。 要求比例因子 :math:`2^e` 的 8
次方根，我们需要 e 是 8 的整数倍。因此，将 4913 的位串向右滑动八位：

:math:`1 001 100 110 001 = 10 011.00110001 \times 2^8`

当然\ :math:`2^8`\ 的8次根就是\ :math:`2^1`.
所以我们寻找一个ULP精度的值\ :math:`(10011.00110001)^{\frac{1}{8}}\times 2^1`,用unum表示的二进制如下

.. figure:: assets/image-20230626163058644.png

   image-20230626163058644

现在执行三个连续的平方根运算，检查每个运算是否存在跨式，并在必要时进行修剪。
（符号“2^^”后跟零和一允许直接输入位字符串。它们使用通常的系统进行颜色编码，以便更容易查看
unum 位字段。）

.. figure:: assets/image-20230626163426586.png

   image-20230626163426586

那个落在 ULP 内，所以不需要修剪。
平方根运算将值的相对宽度缩小约一半，因此新范围大约有一半的时间不会跨越两个
ULP。 执行第二次平方根：

.. figure:: assets/image-20230626163803353.png

   image-20230626163803353

请注意，指数字段不断缩小。 它再次降落在一个可能最小的 ULP 内；
对于最后的平方根，我们不会那么幸运。

.. figure:: assets/image-20230626163909020.png

   image-20230626163909020

由于小数少于四位，因此它跨越了一个精确值。
有两种快速方法可以知道发生了跨式：小数未达到其最大长度，或者答案的
ubound 是 unum 对而不是单个 unum。
这是前者的情况，因为小数字段仅使用其最多四位中的三位。

计算范围 :math:`(1.375, 1.5)` 横跨以下精确的 unum：

.. figure:: assets/image-20230626164610459.png

   image-20230626164610459

通过重复平方求出跨式精确值的 8 次方。 如果它大于原始数字
10011.00110001，那么我们会删除两个 ULP 中较大的一个；
否则我们就修剪较小的那一个。 再次为了说明，以下是所有三个值的 8 次方：

.. figure:: assets/image-20230626164836148.png

   image-20230626164836148

范围 {12.77… ,18.23… } 不包含 10 011.00110001 = 19.19140625，因此被剪掉

.. raw:: html

   <table border="2">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightgray">

读者的练习如果每次使用 k 个嵌套平方根求一个数的 2^k
根时都会发生跨ULP，那么修剪虚假 ULP 范围所需的乘法总数是多少？

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

最后，将最终的 ULP 范围的 unum 按指数 :math:`2^1` 缩放，以获得
:math:`17^{3/8}` 的最大可用精度（使用的小数字段的所有四位）：

.. figure:: assets/image-20230626195620678.png

   image-20230626195620678

在研究计算幂函数的问题时，作者在有关该主题的文献中发现了这一非同寻常且经常被引用的说法：

.. raw:: html

   <table border="2">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightyellow">

“没有人知道对于两个不上溢/下溢的浮点参数计算 y^w，
并且做正确舍入会花费多少……不存在通用方法来预测需要携带多少额外数字来计算
超越表达式并将其正确舍入为某个预先指定的位数。
即使是有限数量的额外数字最终就足够的事实（如果为真）也可能是一个深刻的定理。—
William Kahan

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

真的吗？？

对于读到这里的人来说，这句话的第一部分肯定不再正确。
我们刚刚展示了计算两个浮点数的幂函数所需的最大成本和最长时间。
这样做的高昂成本让我们急于寻找更好的方法，但这是可预测的有限成本和时间，绝对保证。
它与位串相乘和相加的方法一样具有确定性。

引文是具有误导性的，可能是由于遗漏。 这段引文的“…
…”部分可能遗漏了一个解释，即\ **如果 y 和 w 是浮点数，则
:math:`y^w`\ 不是超越函数**\ ，因为这样问题就是代数问题，Kahan知道这一点。
上述引用的第二部分仍然正确，计算超越函数 :math:`e^x` 的实用方法将在 11.7
节中讨论。

11.6 实际考虑和实际工作流程
---------------------------

11.6.1 为什么幂函数可以计算得很快
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

说到这里，可能有读者会想：这家伙是不是疯了？？
精确计算数亿位数字，只是为了保证 :math:`x^y` 的正确性？
这不是这里所提议的。
关于最大位数和最大计算步骤数的争论是为了证明两者都有一个预先已知的有限上限。
这不是计算 :math:`x^y` 的实用方法，而更像是“存在证明”。

在实践中，我们愿意容忍两件事，这可以使寻找 :math:`x^y`
的工作变得更加容易：

-  我们不要求例程对于任意两个输入值始终花费相同的执行时间。
-  我们并不要求每个结果都具有可证明的最小 ULP 宽度

几乎每个 unums
操作都涉及不同数量的执行时间。找到任何精度乘法的最大时间，并坚持处理器始终用那么多时钟周期，即使在将有限数乘以零时也是如此，是很荒唐的做法。
每个操作都应该尽可能快地进行。

至于要求“可证明的最小 ULP 宽度”，有一些计算 :math:`x^y`
的有效方法似乎可以做到这一点，但证明它们总是如此准确是很困难的。
然而，Unum 为此提供了完美的解决方案，因为它们包含准确性信息。
如果存在一种非常罕见的情况，即 :math:`x^y` 的计算是两个 ULP
宽而不是一个，则 ubound 会指出来。 不可能被结果误导，因为 unum
格式允许传达答案的严格界限的宽度。

11.6.2 幂函数原型
~~~~~~~~~~~~~~~~~

该原型处理幂函数的方法与乘法方法类似。
本章开头的等值线图显示了对马鞍形曲面进行“左边”和“右边”端点计算的非常相似的需求。
在这种情况下，鞍座中心的平坦点不在原点，而是在 :math:`x = 1, y = 0`
处。下面的两个表定义了如何处理 x-y 平面中的一般区间端点，其中
:math:`x \ge 1，y \ge 0`

.. figure:: assets/image-20230626202723921.png

   image-20230626202723921

.. figure:: assets/image-20230626202745304.png

   image-20230626202745304

如果 :math:`0 \le x \lt 1`\ ，我们将计算
:math:`1/(1/x)^y`\ ，颠倒左右端点的角色。 如果 x 或 y
为负数，则结果通常为 :math:`NaN`\ （结果是复数而不是实数），除非 y
是整数。 以下是计算幂函数时可能发生的一些特例情况：

-  :math:`0^{-2}=\infty`, 看起来它应该是
   :math:`NaN`\ ，因为我们除以零，但即使是零的负整数幂，结果应该是\ :math:`(\pm\infty)^2=\infty`
-  :math:`1^{(maxreal, \infty)}=1`, 但是\ :math:`1^\infty = NaN`
-  :math:`(-\infty)^\infty=NaN` but :math:`(-\infty)^{-\infty}=0`

**读者的练习** :
在g-layer中，\ :math:`(\frac{1}{2},2]^{[-1,1]}`\ 的正确值是多少？（本章开头的等高线图可能有助于回答这个问题。）

下例是用函数powg计算\ :math:`[\frac{81}{256}, \frac{625}{256})^{0.75}`

.. figure:: assets/image-20230626204227176.png

   image-20230626204227176

u-layer的幂函数\ :math:`u^v`\ 是
**powu**\ [u,v]，它跟踪移动的位数和数字个数。
**powg**\ 和\ **powu**\ 的代码在附录C.15中，由于所有这些特殊情况要处理，它可能是原型unum环境中所有操作中最复杂的。

11.6.3 对浮点数支持者的一个挑战
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

对于那些认为自己有一种巧妙的方法可以使用浮点数在 0.5 ULP 内找到
:math:`x^y` 的人来说，这是一个挑战问题：请计算

.. math::


   5.9604644775390625^{0.875}

根据大多数数学库例程的工作方式，IEEE 双精度的结果可能接近于

.. math::


   4.76837158203125

库例程会将结果舍入为 15 位十进制数。 它还会根据 IEEE
规则的要求在处理器中设置“舍入”位，但你猜怎么着？ 这样做是不对的！
**结果是精确的**\ ，传统的 :math:`x^y` 计算方法无法检测到。

我们只需要一个 {3, 5} 环境即可通过原型获得此结果

.. figure:: assets/image-20230626205128754.png

   image-20230626205128754

区间方法经常因其对结果产生过于保守的陈述而受到批评。
在这种情况下，应该批评的是浮点数。
上个世纪有一个笑话，有人问工程师“二乘三等于多少？”
他拿出计算尺摆弄了几秒钟，然后宣布：“大约是… …六点零。” 如果值可以在
u-layer中精确地表达，并且它们的初等函数也可以精确地表达，那么如果精确结果被错误地标记为“近似”，则应将其视为错误。

**读者的练习** : 构造另一个与上面的例子类似的例子，其中精确的指数
:math:`y` 在小数点右侧至少有三位非零数字，而基数 :math:`x`
在精确表达时至少有十位小数，并且 :math:`x^y` 也是精确的。

11.7 Exp(x) 以及“制表者困境”的解决方案
--------------------------------------

11.7.1 四舍五入不诚实造成的另一个困境
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

指数函数为 :math:`e^x`\ ，也写作
exp(x)，其中\ :math:`e`\ 是自然对数的底数, 2.718281828… 。 与
:math:`x^y` 不同，其中 :math:`x` 和 :math:`y`
都是浮点数，指数函数是超越函数，不能计算为具有有理系数的多项式方程的根。
幸运的是，有一些快速的方法可以以任何精度对其进行求值。
该算法对数字扩展产生紧缩边界，直到它最终落在最小尺寸的 ULP 内。
然而，所需的迭代次数可以是任意大，因为它可能恰好是一个非常接近精确值的无理数，迫使求值“进入超时”以打破平局。

这是超越计算的示例，以十进制形式显示了此类行为。
:math:`e^{\pi\sqrt{163}}`\ 看起来非常像一个整数.
如果对它求值到30个十进制数字精度，结果是

.. math::


   e^{\pi\sqrt{163}}= 262537412640768743.999999999999 \dots

如果最后一位的不确定性甚至小到
:math:`10^{-12}`\ ，则此时不知道得出结果的正确 ULP
是略高于整数还是略低于整数。
对数表的早期制作者首先注意到，对几个条目的舍入是非常难以确定的.

卡汉教授为这种现象创造了“制表者的困境”一词。
它源于向表的用户保证的愿望，“我向您保证，此表中的错误条目的偏差不会超过
ULP 的一半。”
制表者困境是浮点数用户被要求犯下的计算机算术“原罪”的直接后果（见第 3.1
节）。

**Unums 彻底解决了制表者的困境**\ 。 Unum
不担心所谓“正确舍入”结果，因为它们不做舍入。 如果某个值对于最小可能的
ULP 大小来说是未知的，则只需返回保证能保存该值的更大 ULP 大小（或
ubound）； unums
标记边界的大小，而不是返回错误值，unum承认他们不知道的东西。

也就是说，肯定有一种简单的方法可以使像 :math:`e^x`
这样的函数的每个值都落在尽可能小的 ULP 大小中。
要么容忍可变长度计算带有偶尔出现（非常罕见）很长的求值时间，就像托马斯·林奇的高基数在线算术那样，要么简单地提前确定哪些浮点数容易出现问题并用表格处理它们。

假设暂存器里面计算一个超越函数，其位数是小数位数的两倍；
从统计上看，在该精度下，恰好跨越 u-layer中两个 ULP 的情况数量大约为 1 。
这就像跟踪硬盘驱动器上的“坏点”。
找出它们在哪里并解决它们，将一个小表作为库函数的一部分，其中预先计算了一些困难的平局情况，因此不必在运行时决定它们

11.7.2 指数函数原型
~~~~~~~~~~~~~~~~~~~

g-layer版本 **expg** 和 u-layer 版本 **expu** 的代码清单在附录 C.15 中。
因为它是一个单调递增函数，所以所有 ubound
逻辑所要做的就是评估每个边界端点处的函数并跟踪开闭属性。 下面是评估
:math:`e^{(-\infty, 0]}` 的示例:

.. figure:: assets/image-20230626212835527.png

   image-20230626212835527

有时，人们会养成使用 :math:`e^x`
的习惯，而在某些情况下，他们可以使用一个完全可表示的数字作为底数，例如
:math:`10^x` 或 :math:`2^x`\ 。 原型中有提供
**powu**\ :math:`[\hat{10}, u]`, 或 **powu**\ [:math:`\hat{2}, u`]
函数，在原型中使用这些函数的好处是：他们有更多得到精确确的情况。
而超越数\ :math:`e`\ 为基数，只有当 :math:`x` 为 :math:`-\infty`\ 、0 或
:math:`\infty` 时，\ :math:`e^x` 才精确的。

**读者的练习** : 如果我们在 {2, 2} 环境中限制 utag 左侧最多 5 位，则有
66 个非负可能的 unum 值：

.. figure:: assets/image-20230626213745033.png

   image-20230626213745033

如果我们包括这些数的负值，那么就会产生 131 个不同的精确 unum。
在上面的集合中，对于哪一个 :math:`2^x` 也是精确的？
（提示：超过百分之十的值都会发生这种情况！）
