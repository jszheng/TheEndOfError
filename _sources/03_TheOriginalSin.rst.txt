
3. 计算机算术的原罪
===================

3.1 接受不准确的答案
--------------------

二进制浮点数可以表示很大和非常小的数字，并且精度范围很广。但是它们不能表示所有实数。它们只能表示分母为2的幂的有理数。有些读者可能会对此声明感到吃惊，因为他们很早以前就习惯了使用浮点数代表平方根，\ :math:`\pi`\ ，小数等等，甚至被教导浮点数旨在表示实数。那问题出在哪里？

计算机算术的“原罪”就出在当用户接受以下命题时：

.. raw:: html

   <table border="2">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightyellow">

抱歉，计算机无法给您确切的值。请改用此值，那跟真实值很近。

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

如果有人抗议，通常会告诉他们：“表示每个实数的唯一方法是使用无限的比特位。由于计算机具有有限的内存，因此它们仅具有有限的精度。接受它吧。”

**我们完全没有理由接受，这个推理是有缺陷的。**
数百年来，人类一直以一种简单而有限的方式来表达大量实数。如果被问到“:math:`\pi`\ 的值是什么？”聪明且正确的答案是“
3.14…”，其中“…”表示最后一位之后还有很多有效位数。而如果问“七除以二是多少？”那么答案可以表示为“
3.5”，最后一位之后空格表示数是完全精确的。有时我们需要比空格更明确的内容来显示准确性。

.. raw:: html

   <table border="4">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightblue">

定义:
＂↓＂符号放在一组显示的小数位数的末尾时，强调右侧的所有数字均为零；
显示的小数是准确的。

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

正如有符号数表示的正号（空白）或负号＇–＇被写在数字的左侧一样，精确性是一种二态指示符，右侧空白表示精确或“…””表示不精确。
当我们想表达得更清楚时，我们在正数之前明确地加上“ +”，而不是空白。
同样，我们可以在一个精确的的数字序列后面加上符号“:math:`\downarrow`”，以强调“这些数字在“\ :math:`\downarrow`”处停止。”
或者说最后一个之后的所有位都是0。这只需要多一位存储，我们称为\ **ubit**\ 。

.. raw:: html

   <table border="4">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightblue">

定义:
ubit（不确定性位）是小数的末尾一位，如果小数精确，则为0；如果小数中有更多非零位，但没有空间将其存储在unum的特定格式设置中，则为1。

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

如果所显示的最后一位右边的小数中的位全为0，则它是精确值。
如果有一个无限长的1位字符串，它也是精确的，并且值等于小数最后一位加1，同样5.999999…如果9的数目是无限的，则与6相同。
如果设置了ubit，则表示的数量是介于全0的精确值和全1精确值之间的所有实数。最接近Ubit的历史先例的是Pat
Sterbenz在他的绝版书中＂浮点计算Floating-Point
Computation（1974）＂描述的“舍入为粘性位”。
他用该位指示“可以计算更多的位”。 他也将其放在分数的末尾。

数值分析师使用一个术语来表示数字和下一个较大的分数值所表示的数字之间的差：\ :math:`ULP`\ 。

.. raw:: html

   <table border="4">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightblue">

定义:
ULP（读做gulp）是由位串表示数与的精确值之间的差，与该位串最后一位（小数的最后一位）相差一个单位。

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

（某些文章使用“Unit of Least
Precision最低精度单位”作为缩写短语。）例如，如果我们有定点二进制数\ :math:`1.0010`\ ，\ :math:`ULP`\ 是最后一个0的位置，而大一个\ :math:`ULP`\ 的数字就是\ :math:`1.0011`\ 。

所以如果数值是精确的我们用“:math:`1.0010\downarrow`”表示，而用“:math:`1.0010\ldots`”表示介于\ :math:`1.0010`\ 和\ :math:`1.0011`\ 所有数（开区间,
不含两端的精确数）．通常我们用括号括起来的两个数来表示开区间\ :math:`(1.0010，1.0011)`\ ．方括号用来表示闭区间\ :math:`[1.0010，1.0011]`,但我们这里不是闭区间．当ubit设置上后表示的是一个ulp宽度的开区间．下面是数的格式，其中洋红色表示ubit.

.. figure:: assets/image-20200713093400770.png

   image-20200713093400770

其中h代表隐藏位(hidden bit). 当指数为全０时候是０，其他情况是１．

假设我们还是用5ｂ的浮点表示，一位符号，２位指数，１位小数，最后一位ubit．我们可以表示的数有哪些呢？一些例子：

-  :math:`\color{red}{0}\,\color{blue}{00}\,\color{black}{1}\,\color{magenta}{0}`
   表示精确的\ :math:`\frac{1}{2}`, (隐藏位为０)
-  :math:`\color{red}{0}\,\color{blue}{00}\,\color{black}{1}\,\color{magenta}{1}`
   表示开区间\ :math:`(\frac{1}{2}, 1)`,
   所有满足的\ :math:`\frac{1}{2}\lt x \lt 1`\ 实数
-  :math:`\color{red}{0}\,\color{blue}{01}\,\color{black}{0}\,\color{magenta}{0}`
   表示精确的1

通过在\ **精确数字**\ 和\ **区间数字**\ 的交替，含义单调增加并整洁地“平铺”满了完整的实数线。
我们不再需要犯下“原罪”，即用不正确的确切数字代替正确的数字。
如果计算2÷3，则此五位格式的答案是开区间\ :math:`(\frac{1}{2}, 1)`\ ，其格式为\ :math:`\color{red}{0}\,\color{blue}{00}\,\color{black}{1}\,\color{magenta}{1}`
。这可能是关于值\ :math:`\frac{2}{3}`\ 的非常低精度的表达，但至少是事实。
如果改用浮点数，则必须在两个谎言之间进行选择:
:math:`\frac{2}{3}=\frac{1}{2}`\ 或是\ :math:`\frac{2}{3}=1`

浮点数的硬件设计人员及其数学库必须跨过障碍才能进行所谓“正确的舍入”(correct
rounding)，意思是舍入误差不得超过0.5 ULP。
想象一下，您必须计算多少个额外的位，才能弄清楚哪种取整方法。
对于许多常见函数（例如\ :math:`e^x`\ ），无法预先预测要计算多少位数才能正确舍入它！
至少ubit消除了舍入所需的额外计算。
一旦计算机确定分数中最右边的位之外还有非零位，它只需将ubit设置为1即可完成。

下节会显示ubit的意外收益：它提供了一种优雅的方式来表示两种NaN。

3.2 ＂几乎无限＂和＂超过无限＂
------------------------------

.. figure:: assets/image-20200713113017297.png

   image-20200713113017297

..

   .. raw:: html

      <center>

   这幅图是来源与2001年电影《太空漫游》的最后一辑“JUPITER AND BEYOND THE
   INFINITE木星及无限苍穹”。
   这辑的标题可能是皮克斯（Pixar）动画人物巴斯光年Buzz
   Lightyear角色的口号“To Infinity…and Beyond！”的灵感来源。
   “超越无限”正是unums表达NaN数量的方式。

   .. raw:: html

      </center>

回想一下，我们使用了最大幅度的位串（指数和分数中的所有位都设置为1）以及符号位来表示正负无穷大。最大的有限数的分数只比它小一个ULP，因此它们的最右边分数位是0。在这种情况下添加ubit意味着什么？

可能看起来很奇怪，但我们把\ :math:`+\infty`\ 和\ :math:`–\infty`\ 看做是“精确”数字。有时人们会说一些数目(例如天空中的恒星数量)是“几乎无限”，但是语法学家会指出“几乎－无限”是矛盾的，因为它意味着“有限”。实际上，“几乎无限”是一个有用的计算概念，因为它表示一个太大的有限数字，无法表达。

.. raw:: html

   <table border="4">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightblue">

定义: 值　maxreal　是可以表达的最大有限值。比无穷大表示少一个ULP

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

使用ubit表示法，可以表示开区间\ :math:`(maxreal，+\infty)`\ :math:`和`\ :math:`(–\infty, -maxreal)`\ ，这表示“几乎是无限的”。这表示的是有限的实数，但是太大而无法精确的用这么少的比特数区分开来表示。

这是与扩展精度算术完全不同的方法，后者使用软件例程通过使用超大数字来表达和执行算术运算，增加附加位直到存储空间用完。

按照2.5节的5位浮点例子，我们用非IEEE方式表达正负无穷

:math:`\color{red}{0}\,\color{blue}{11}\,\color{black}{1}\,\color{magenta}{0}`
是 :math:`+\infty` (符号位=0，值是正，所有指数与分数都是１)

:math:`\color{red}{1}\,\color{blue}{11}\,\color{black}{1}\,\color{magenta}{0}`
是 :math:`+\infty` (符号位=1，值是负，所有指数与分数都是１)

ubit为0表示无穷大这个数是精确的表示．最大的有限数是分数小1位,
比正负无穷小一个ulp

:math:`\color{red}{0}\,\color{blue}{11}\,\color{black}{0}\,\color{magenta}{0}`
是 :math:`+4` , 按照浮点格式有隐藏位=1

:math:`\color{red}{1}\,\color{blue}{11}\,\color{black}{0}\,\color{magenta}{0}`
是 :math:`-4` ,

当我们设置了ubit后，表示接近无限．这能表示的最大数还要大，但是还是属于\ **有限**\ 的

:math:`\color{red}{0}\,\color{blue}{11}\,\color{black}{0}\,\color{magenta}{１}`
是开区间\ :math:`(4, \infty)`

:math:`\color{red}{1}\,\color{blue}{11}\,\color{black}{0}\,\color{magenta}{１}`
是开区间 :math:`(-\infty, -4)`

如果设置了ubit表示“比当前表达的精确数大一个ulp”,
那么无限这个精确数置位ubit又是什么意思呢？
这里你应该微笑了，因为“超越无限”是没有意义的。
但是我们正需要一种方式来无意义的数，那就是NaN！
因此，我们可以将“超出正无穷大”定义为安静的NaN，将“超过负无穷大”定义为发信号NaN，这里用红色表示，因为它表示“停止计算！”

:math:`\color{red}{0}\,\color{blue}{11}\,\color{black}{1}\,\color{magenta}{1}`
是 quiet :math:`NaN`

:math:`\color{red}{1}\,\color{blue}{11}\,\color{black}{1}\,\color{magenta}{1}`
是 signaling :math:`\color{red}{NaN}`

在最大数的另一端有对应的我们称为“小的亚归一化数” small subnormal

.. raw:: html

   <table border="4">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightblue">

定义: 值　small subnormal　是可以表达的最小有限值。比０表示大一个ULP

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

有时人们会使用“几乎没有”这个词，同样的，语法学家也可能会再次说：“这意味着是’有东西’，因此’几乎没有’是矛盾的，就像’巨大的小虾’Jumbo
Shrimp”。 但是，“几乎没有”和“几乎无限”一样有用。
它的意思是“不是零，而是比我们可以表达的数字少”。

ubit让我们优雅地代表这个概念：超越零。
并且它赋予可以有“负零”的含义，因为它告诉跟0之间的ULP间隔指向哪个端点方向。

:math:`\color{red}{0}\,\color{blue}{00}\,\color{black}{0}\,\color{magenta}{0}`
表示精确的\ :math:`0`

:math:`\color{red}{1}\,\color{blue}{00}\,\color{black}{0}\,\color{magenta}{0}`
也表示精确的\ :math:`0`, 零无需看符号

但是

:math:`\color{red}{0}\,\color{blue}{00}\,\color{black}{0}\,\color{magenta}{1}`
表示开区间\ :math:`(0, smallsubnormal)`

:math:`\color{red}{1}\,\color{blue}{00}\,\color{black}{0}\,\color{magenta}{1}`
表示开区间\ :math:`(-smallsubnormal, 0)`

顺便说一句，气象学家在写道温度为负零，即-0°时就已经使用了这个想法。
这意味着温度在–0.5°至0°之间，而写入0°则意味着温度在0°至0.5°之间。
对于气象人员来说，传达温度是高于还是低于水的冰点（0摄氏度）显然很关键。

最小的可表示非零数字在分数的最后一位为1，所有其他位均为0。由于指数中具有所有0的位使其成为亚归一化数subnormal，因此无论有多少位指数和分数，我们都将其称为smallsubnormal。
我们正在使用的只有五位的这种低精度情况下，最小的非零数是\ :math:`\frac{1}{2}`
，但是一旦我们开始使用较大的位串，它当然通常会小得多。

3.3 没有上溢，没有下溢，也没有舍入
----------------------------------

如果数字太大而无法用特定的浮点精度表示（溢出），我们该怎么办？
IEEE标准规定，当计算溢出时，应使用值\ :math:`\infty`\ 进行进一步的计算。但是，将“有限溢出结果”设置为精确值\ :math:`\infty`\ 无限是超级\ *无限*\ 的错误。同样，当一个数字变得太小而无法表达时，标准会说改用0。某些结果的使用方式，两种替代都可能会对计算造成灾难性的影响。该标准还指出，应在处理器寄存器中设置一个标志位，以指示是否发生过溢出。下溢甚至是“四舍五入”也有一个不同的标志。

问题是\ **没人**\ 去看过这些标志。

计算机语言无法查看这些标志，即使计算环境开始报告中间下溢或上溢警告，只要计算结果看起来还不错，大多数用户也会找到如何禁用该报告的方法，而这通常会提高计算速度。尽管计算机用户发现这些标志好的情况下基本没有用处，坏的情况是很烦人的，但芯片设计人员仍然被要求将标志放入浮点运算单元中。

.. raw:: html

   <table border="2">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightblue">

IEEE设计中的一个基本错误是将“
inexact”描述放在三个处理器标记中，这对于计算机用户来说是非常难于访问的。正确的位置应该在数字本身中，分数末尾有的ubit上。只需在数字中放置该位，就无需上溢，下溢和舍入标志。

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

我们不需要上溢，因为我们有“几乎无限”的值：\ :math:`(maxreal，\infty)`\ 和\ :math:`(-\infty，-maxreal)`\ 。

我们不需要下溢，因为我们有“几乎没有”的值：\ :math:`(-smallsubnormal，0)`\ 和：\ :math:`(0，smallsubnormal)`\ 。计算永远都不会错误地告诉您，例如\ :math:`10^{-100 000}`\ 等于零，并带有一个隐藏（或有意禁用）的下溢错误标志位。而是将结果标记为-严格大于零，但严格小于最小可表示数字。同样，如果您尝试计算约十亿的十亿的幂，则无需错误地替换无穷大，也无需发出溢出警报。

如果您要求\ :math:`\pi`\ 的值（具有五位小数和一个ubit），您将获得值位于开放时间间隔（3.125，3.25）中，这是一个正确的陈述。无需在处理器中设置“四舍五入”标志，标志位是一个“粘性”位，因为它会一直保持置位状态，直到操作系统中的某些内容对其进行重置为止。例如，可能会发生（3.125，3.25）乘以零并再次变为精确的结果情况。
“四舍五入”标志就像一辆常亮“ CHECK ENGINE”灯的汽车，但仍然似乎运转良好.

.. figure:: assets/image-20200713140246175.png

   image-20200713140246175

关于在数字格式本身中记录是否精确描述的最后一条评论。
如果您在计算器上输入一个大正数，然后一遍又一遍地按平方根按钮，最终显示屏将精确显示1.0000000。
当然，这是不正确的。
该错误非常类似于将溢出数设置为无穷大或将下溢数设置为零。
对于小数点后的ubit，答案可以是“ 1.00000…”，并带有永不消失的“…”。
该数字始终标记为“大于1，但超过的数量太小而无法表达”。
传统的区间算法无法做到这一点，并且会产生与float相同的错误，接受精确1作为答案（区间两端都无限逼进１最后结果是精确的1)。

下面代码用unum反复做平方根，数学上是无限loop,

.. figure:: assets/image-20200713140933757.png

   image-20200713140933757

这里停止了迭代．双精度浮点数错误地声明了最后一个结果-恰好等于1。

许多科学计算都涉及迭代和测试收敛性，使用浮点表示法时，“停止标准”是错误和额外编程工作的来源。
Ubit保护我们避免错误地将一个精确数误以为是渐近逼近该值的数。

3.4 可视化带ubit的数
--------------------

浮点数旨在允许使用（近似）实数进行计算。
对于到目前为止讨论的所有格式，位字符串只能表示离散的精确值，因此，值图由一系列点组成。
通过ubit扩展，我们现在可以覆盖整个实数线以及\ :math:`–\infty`\ 和\ :math:`\infty`\ 以及两种NaN类型。

对于先前使用的五位情况，见下面的值图，其中包含精确数字的点和带有圆角的矩形，以提醒我们它们是精确数字之间的开区间：

.. figure:: assets/image-20200713141911626.png

   image-20200713141911626

与以前的图形相比，有两个细微的变化，除了包含开放的区域而不包含点值之外，您可能误把–5和5作为\ :math:`+\infty`\ 和\ :math:`–\infty`\ 的值，但事实上在
y轴箭头指向两个方向，整个实数线现在由位字符串表示。
所以我们将y轴的标签从“十进制值”更改为“代表的值”。

下一个问题是，在进行加减乘除运算时，闭包方面是否更好。
是好但是仍然不完美。
原因是我们只能表示一个ULP宽的范围，而许多运算所产生的结果都比一个ULP宽。
例如\ :math:`(0, \frac{1}{2})+(0, \frac{1}{2})=(0, 1)`\ ，但是无法用这种格式表示间隔（0，1）。

下图是5bit带ubit的浮点计算闭环图

.. figure:: assets/image-20200713154703906.png

   image-20200713154703906

上溢和下溢的情况没有了。
我们迫切希望拥有一个封闭的系统，在该系统中，算术结果始终可以表示，而不会四舍五入或以其他方式损害正确性。
每当我们添加一些东西来适应一种新的数值类型时，我们就有可能创建更多不符合格式的例子。
这会是一个无休止的过程，抑或是有能创建一个封闭，有限比特数来对实数进行真实算术运算的系统？

.. raw:: html

   <table border="2">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightgray">

给读者的练习:
有没有可能用一个没有小数位，但仍然使用ubit的数，能覆盖实数轴。
按照前面定义的指数偏移，隐藏位等描述的格式定义，用一个符号位，两个指数位，无小数位和ubit能表示的不同值是什么？
如果将IEEE规则用于无穷大和NaN值而不是此处描述的方法，又可以表示多少个不同的值？?

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>
