
17 “解”方程到底是什么意思？
===========================

.. figure:: assets/image-20230703120902426.png

   image-20230703120902426

..

   这是一个绝望的同学如何回答这个问题的。本章也是关于找x的，就像这个例子一样，我们可能以一种数学老师没有想到的方式找到这个x.

17.1 传统数值方法的另一个突破
-----------------------------

在试图用ubox完整地解决一个应用前，我们需要有一个ubox版本的解方程的工具，就像你编程用的一个软件库一样。关于如何接方程，有堆成山的文献讲述了各种复杂的方法。但是ubox的方法与这些很不一样。首先一点，ubox方法一点也不复杂，因此很容易使用。

传统的方法是要尽可能减少舍入误差。既然unum和ubox都不产生舍入误差，而是追踪在一个ULP范围的精确值，我们需要重新审视在计算机上“解方程”的真正含义。同样地，我们寻找的是不需要程序员有数值计算知识的一种方式，从而把绝大多数的工作都转到计算机来做正确的工作。

即使一个最简单的一元线性方程也说明了需要一个新的方式

17.2 一元线性方程，用逆运算解决
-------------------------------

每个人都应该在小学就看到过类似 “:math:`3x+6=0`\ ，那么x是多少？”
这样的问题。数学老师在问你“解x”或是“找到x”时候，隐含是让你“重新安排方程，尽量把未知的量独自放到左边，其他放右边”。

代数老师的方式就是不停地撤销对于x的操作，通过做逆运算直到只剩下x自身在方程的左边，而右边就是对已知数的各自操作。所以要撤销左边的+6，我们两边同时减6，得到“:math:`3x=-6`”，然后我们撤销乘3操作，对方程用逆运算除3得到：“:math:`x=-6/3`”。方程右边现在是已知量，可以简化成-2.
这样解问题“x取什么值才能满足方程\ :math:`bx+c=0`”的答案是\ :math:`x=-c/b`\ 。显然这是很合理一个让计算机解方程\ :math:`bx+c=0`\ 的方法.
c取反再被b除，完了。

但是b要是0呢？是要用-c除以0得到NaN吗？重新研究下原始问题。如果b是0
（而且我们假设x是有限值），问题就变成了“x为什么值的时候c=0?”
看上去是个愚蠢的问题，因为x都不在方程中。但是这个问题有一个合乎逻辑的答案。如果c不等于0，
答案就是“无解，没有x的值满足c=0”。而如果c碰巧就是0，那么答案就是“x取任何值都满足方程0=0”。

要是b是无限呢？或是负无限呢？如果c是有限的，那么公式\ :math:`\frac{-c}{b}`\ 得出0是答案。但是这不对，因为\ :math:`\infty\cdot0=NaN`\ 。又如果c是无限或是负无限呢？你没有办法把无限或是负无限相加得出一个有限数。所以一个很谨慎的答案有3个情况

.. figure:: assets/image-20230703133428436.png

   image-20230703133428436

所以得出的一个基本原则是：计算“解算”一个方程跟数学上“解”一个方程是不一样的含义。你也许被教育着首先根据数学原理用逆函数把x变换到方程左边，然后将方程右边公式输入计算机。这过程中如上面所说，忽略了很多特殊情况从而带来了错误。

更重要的是传统的计算数学有舍入-上溢-下溢的错误，所以不能相信它能匹配数学的答案，即使上面是最简单的情况。

.. raw:: html

   <table border="2">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightblue">

在计算机上“解方程”实际上是这个意思：找到一个最小的但是是完全的可表示值的集合，其计算机版本的数学方程式是真。换句话说，找到转换后的方程c-solution

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

奇怪的是，所有声称解方程的计算机程序几乎没有一个真的做到这些。他们要么只给出一个值而忽略了其他可以满足的值，所以解是不完全的，要么就含有不能让原始方程式相等的值。即使是Mathematica软件也有时候糊涂了，比如说满足“0=0”的数值解是空集。

.. figure:: assets/image-20230703135521864.png

   image-20230703135521864

如果你用浮点算术，对方程“:math:`bx+c=0`”的解几乎\ **总是错的**\ 。比如如果你试图用浮点解\ :math:`7x-2=0`\ 并使用\ :math:`\frac{-c}{b}`\ 公式计算，你会得到：

-  :math:`x=\frac{2}{7}`, 半精度是\ :math:`\frac{585}{2048}`,
   但是代回方程\ :math:`7x-2`\ 得到\ :math:`-\frac{1}{2048}`, 不等于0.
-  :math:`x=\frac{2}{7}`, 单精度是\ :math:`\frac{9586981}{33554432}`,
   但是代回方程\ :math:`7x-2`\ 得到\ :math:`\frac{3}{33554432}`,
   不等于0.
-  :math:`x=\frac{2}{7}`,
   双精度是\ :math:`\frac{10293942005418277}{36028797018963968}`,
   但是代回方程\ :math:`7x-2`\ 得到\ :math:`\frac{3}{36028797018963968}`,
   不等于0.

所以最终如果一个用浮点解x的程序后面来到一个像下面的测试语句

.. figure:: assets/image-20230703141436948.png

   image-20230703141436948

不管用什么精度它总是会去做错误的事情。所以浮点数的一个绕过问题的方法是测试结果是否“*接近*”，而“接近”的定义是靠人定义，每个地方都不同。而且“接近”的定义到底是按绝对误差还是相对误差啊？还有更多需要人来决定的。这些绕过问题的方法让代码既难写又难读。

17.2.1 unum和间隔的求逆
~~~~~~~~~~~~~~~~~~~~~~~

因为unum是遵循数学规则的，所以用求逆运算是安全的。结果永远含有上面定义的，但不是永远是满足原始方程的最小集合。其实就是c-solution。如果结果是按最小的ULP宽度为单位的多个ULP，
那么一个方法就是构建一个ubox集合作为逆操作的结果，做法是测试原始方程，丢弃失败的，就得到了方程的c-solution.

对于线性方程，\ :math:`\frac{-c}{b}`\ 总是最小宽度无需再调优。比如一个中等的环境{1,
3},
对于\ :math:`7x-2=0`\ 方程的unum版本\ :math:`\hat{7} \otimes xu \ominus \hat{2} \approx \hat{0}`\ 解\ :math:`\frac{-c}{b}`\ 是

.. math::


   negateu[\hat{-2}] \odot \hat{7} = (\frac{73}{256}, \frac{74}{256})

也就是\ :math:`0.28515625 \le x \le 0.2890625`\ ；这是一个正确的声明，而且unum是一个最小ULP宽度，没有必要再分割了。而且结果是一致的，unum的比特表示是0
00 01001001
11111，只占用16bit，代回到\ :math:`7x-2`\ 得到开区间\ :math:`(-\frac{1}{256}, \frac{3}{256})`,
其中包含0.

一个unum程序后面可以做如下测试

.. figure:: assets/image-20230703150759553.png

   image-20230703150759553

无论使用什么环境，结果的True或是False都是正确的，也不需要插入“接近度”容错的修正代码

那这跟区间算术有什么不一样呢？区间算术如果说使用半精度浮点表示边界点，就是\ :math:`\frac{585}{2048} \le x \le \frac{586}{2048}`\ ，
是一个真的声明，只是没有必要包含边界点。而且占用了32b来描述x.

更大的问题在于，传统的间隔非常容易上溢或下溢，
即使是单变量线性方程。比如用单精度回答下面问题

   满足\ :math:`\frac{1}{64}x-10000=0`\ 的x值是什么？

整数算术是数学上完全严格的，所以我们可以用\ :math:`\frac{-c}{b}`\ 公式。而且值\ :math:`b=\frac{1}{64}`\ 和\ :math:`c=-10000`\ 都是半精度可以准确表示的值。而且b或c都没有0，所以不需要处理特别情况。但是传统的间隔算术在做上边界除法的时候上溢了，答案变成了x可以是正无穷。

更糟糕的事情是比如下面这个方程

   满足\ :math:`10^{-8}x+10^{-8}=0`\ 的x的值是什么？

显然结果应该是\ :math:`x=-1`,
但是b和c的值在半精度下都下溢了。所以最终方程的b和c都被当成了0.
一个浮点算法跌到了第三个选项，答案是所有的实数都是解。

如果我们试图用传统的间隔，边界bounds，b 和
c都是闭区间\ :math:`[0, \frac{1}{16777216}]`, 那么去匹配下面这些选项吧

.. figure:: assets/image-20230703152746757.png

   image-20230703152746757

**选哪个case呢**\ ？b和c都可以被当做非零或是零，答案就是很难看的多种选择包括:
间隔\ :math:`[-\infty, 0]`, “空集”或是“所有实数”。

目前我们所有的样例都是用精确的值作为b和c。
那么用ubound表示的间隔作为系数又如何呢？

17.2.2 ubound作为系数
~~~~~~~~~~~~~~~~~~~~~

目前我们看到的都是b和c表示为单个unum，所以他们要么是精确的，或是一个ULP宽度，不会跨越0.
线性方程的b和c可以不仅仅是实数，也可以是一般间隔。这个情况就更复杂了。有18中情况出现，其中有些还很怪异。方程\ :math:`y=bx+c`\ 描述了一根直线，斜率为b，在y轴上交点为c.
但是当b和c是一个范围的值的话，方程表示的图就像一个领结，斜率是摆动的，中间是宽度不为零的夹点在y轴上。

比如下图是\ :math:`bx+c`\ 的图，其中b的范围是-0.5到0.25，交在y轴上的c范围是0.25到0.375.

.. figure:: assets/image-20230703154001093.png

   image-20230703154001093

从这个图上可以看到方程\ :math:`bx+c=0`\ 是两个不相连的范围。一个是从\ :math:`-\infty`\ 到-1,
另外一个是从0.5到\ :math:`\infty`.
端点-1和0.5的开闭取决与b和c端点的开闭情况。

假设b的范围是(-0.5, 0.25), 而y的交点是(0, 0.375),
结果就是所有的数除了零。

.. figure:: assets/image-20230703154420787.png

   image-20230703154420787

**读者的练习**\ ：方程\ :math:`bx+c=0`\ 也可以用融合的乘加来表示:
:math:`fmau[\hat{b},\hat{x}, \hat{c}]\approx\hat{0}`.
使用融合乘加的结果会得到比分离的\ :math:`\hat{b}\otimes\hat{x}\oplus\hat{c}\approx\hat{0}`\ 更紧的结果吗？

回忆一下什么叫“解方程”？：是找到\ **所有**\ 的满足方程的值，而不只是通过逆运算得到的一个值。逆运算需要处理很多特例，所以这不是最好的方法。要写一个直接解方程\ :math:`bx+c=0`\ 的程序，我们需要考虑6种b可能的情况

1. 精确的0
2. 精确的0到正数
3. 负数到精确的0
4. 严格大于0的数
5. 严格小于0的数
6. 从负数到正数

而c需要考虑以下三个情况

1. 含有0
2. 严格大于0
3. 严格小于0

这就是为什么需要18种情况，还没有考虑特殊输入值如无穷和NaN情况。应该把这么复杂的代码做成数学库，让普通程序员无需处理这样的事情。下面的x-y图是这些case对于方程\ :math:`y=bx+c`\ 的所有表示

.. figure:: assets/image-20230703160428137.png

   image-20230703160428137

其中比较微妙的一个方面是第一列，当c包含0，b=0的情况，解集是
:math:`-\infty \lt x \lt \infty`\ ，为什么解集不包含无穷，图上画的好像是包含的。除非我们仔细定义方程为

.. figure:: assets/image-20230703161009911.png

   image-20230703161009911

没有这样的定义，就不能说\ :math:`x=\infty`\ 满足方程\ :math:`0 x+c=0`\ ，因为乘法的结果将会是NaN.

而注意左下角的解就变成了包含无穷了。b包含0且c包含0，结果的确是
:math:`-\infty \le x \le \infty`,
无穷乘以一个跨越0的区间的确产生了范围包含整个实数区域。这就是一个典型例子来说明一个数学的陈述翻译成计算机通常并不一定是相同的。

.. raw:: html

   <table border="2">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightblue">

到目前的讨论都是对于一个哪怕最简单的数学问题找到c-solution都是很复杂的。下一节将反过来，ubox提供了令人惊讶的简单和鲁棒的方法，可用于大范围的问题，且不需要程序员拥有除了编程以外的任何知识

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

17.3 “尝试所有的！”数轴上的穷举搜索
-----------------------------------

17.3.1 重温二次方程
~~~~~~~~~~~~~~~~~~~

.. figure:: assets/image-20230703162600603.png

   image-20230703162600603

在本书第一部分中，我们展示了用unum和最原始的二次方程解的公式求解如下二次方程\ :math:`ax^2+bx+c=0`\ 可以得出安全和可用的结果。二次方程解的公式是一个很好的逆操作方式的例子，一些人首先就需要努力才能推导出这个解

.. math::


   r_1, r_2 = \frac{-b\pm\sqrt{b^2-4ac}}{2a}

除非你常常用数学，小学以后也许你就忘记这个公式了，需要的时候还需要查一下。

上一节展示了解决线性方程用逆运算有多复杂。如果你需要建立一个unum库来解二次方程，用不同情况来逐一解决，那么下图就显示你要处理多么复杂的情况

.. figure:: assets/image-20230703170035500.png

   image-20230703170035500

你一直被教导说二次方程最多有两个根，但是如果系数是非精确的，那么实际上实数轴上有三个区域都可以让方程为0.
至少我们知道，如果a=0,
方程退化为前一节讲的只有18种情况的一次方程。而如果a不是严格的0，那么就有附加几十种情况需要折腾，如同上面这种奇怪的状况。平方根号里面的数可以是0或是负数，也需要分开处理。为每种状况分别处理不是一种很有效的方法，有更好的方法。

17.3.2 大胆地分割无穷大：尝试一切
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Unum
math提供了如此简单和无痛的东西，以至于它似乎好得令人难以置信。它可以快速测试整个实数线，以筛选出不必要的工作。例如，假设要求解的二次方程为

.. math::


   x^2+1=0

如果答案必须是实数，则无解。您可以计算平方根内的值，\ :math:`b^2 - 4 a c`
并测试它是否为负数，但这算是很多工作了。我们可以更轻松地完成：尝试
:math:`[-\infty, \infty]`\ 。如果有任何地方存在\ :math:`x^2 + 1 = 0`
的解，那么 unum 版本将产生 True。试试吧：

.. figure:: assets/image-20230703195956414.png

   image-20230703195956414

只需一次乘法、一次加法和一次比较，unum math
就筛选出是否需要任何进一步工作。False
结果并不意味着该方法根本找不到解;它证明了在整个实数线的任何地方都没有解，并且
:math:`-\infty` 或 :math:`+\infty`
也不是方程的解。使用“:math:`\approx`”而不用“:math:`\equiv`”作为相等性测试是关键，因为“:math:`\approx \hat{0}`\ ’”表示与零相交。

有了这个想法，我们可以重新审视第 1 部分中的示例:
:math:`3x^2+100x+2=0`\ 。用unum形式定义函数为\ **quadu**\ [ub],
ub是任何ubound，这里用了polyu来避免任何依赖性问题让函数求值变得更宽松。

.. figure:: assets/image-20230703201727673.png

   image-20230703201727673

第一步只是看看是否有解。找出答案只需要调用quad，使用整个实数线\ :math:`(-\infty, \infty)`

.. figure:: assets/image-20230703201927438.png

   image-20230703201927438

结果为真意味着值得再做一些检查。在第 1 部分中，使用的环境是最接近 IEEE
单精度的环境，即 {3、5} 的环境;
直接使用二次公式对于最接近零的根（因数字抵消而丢失信息的根）给出了以下结果：

   (–**0.02001201**\ 60…,–**0.02001201**\ 36…)

很难阅读这么多小数，因此数字不同的以橙色显示。上述界限的宽度为\ :math:`2.4\cdots\times 10^{-9}`\ ，比最小ULP尺寸大数百倍。这意味着它可能包含一些不满足原始方程的unum，因此可能不符合c解的定义。

原型中的\ **solveforub**\ [domain]函数采用一组ubounds域，这些域定义了要在其中搜索的实数线的区域，并假定已经定义了真条件函数\ **conditionQ**\ [ub]。\ **solveforub**
的代码在附录 D.8 中。该算法的说明如下：

::

   将trials集设置为域，将solutions设置为空集 {}。
   当trials集为非空时：
       将 new 设置为空集 {}。
       对于trials中的每个 ubound ub：
           测试 ub 是否满足真值条件。
           如果是，尝试将其拆分为较小的 ubound。
               如果 ub 是最小的 ULP（不可拆分），请将其添加到solution集中;
               否则，将拆分添加到new和trials中;从trials中删除 ub 。
           将trials设置为new。
   返回solutions 作为真值条件的 c-solution。

在向solutions集添加 ubound
时，它会与已经存在的任何邻居合并。执行此操作的原型函数是
**ubinsert**\ [set， ub]，其中 set 包含 ubounds，ub 是要添加到set中的
ubound，可以作为实数的独立范围，也可以（如果可能）连接到集合中的现有
ubound。

其中“*尝试将其拆分为较小的
ubound*”的任务可以用各种不同方式做，原型中做分割的函数是\ **splitub**\ [ub]，你可以给splitub整个实数区间，和无限边界点。它首先被分割为\ :math:`-\infty, (-\infty, \infty)`

和\ :math:`\infty`\ 。优先是使得探索的区域落到有限的区域。所以\ :math:`(-\infty, \infty)`\ 又被分割为\ :math:`(-\infty,-maxreal), -maxreal, (-maxreal, \infty)`\ 。然后右边区间\ :math:`(-maxreal, \infty)`\ 在maxreal点被分割。然后优先级是在正负数区分上，分割点在0.
再往下就是使用最粗粒度的ULP尺度分割了。下图显示了整个分割过程。

.. figure:: assets/image-20230703211947848.png

   image-20230703211947848

**solveforub**\ 函数返回c-solution:
最小，完全和最紧致的满足方程式的可表示值的集合。试试在二次方程上使用看能否自动找到跟好的集合。我们不需要很大的指数，一个{2,
5}的环境就足够了。解的范围付给变量\ **sols**\ 。然后用十进制显示

.. figure:: assets/image-20230704074026301.png

   image-20230704074026301

两个根的开区间表示边界只有一个最小ULP宽度，比用求逆的方式得出来的结果信息量多上百倍。

17.3.3 高度可调的并行度
~~~~~~~~~~~~~~~~~~~~~~~

每个区域拆分都会创建三个独立的 ubound
进行测试。这些测试可以使用最简单的并行形式并行完成：对不同的数据进行相同的操作。如果我们愿意，分割出的子区域数量可能远远超过三个。任何
ubound 都可以使用 uboxlist 拆分为多个较小的
ubound，而不是简单的拆分。如果你手边有 1024
个处理器，为什么不给他们每个人一些事情来推进答案呢？这是计算机系统可以做出的选择，而不是用户，因为操作系统知道哪些处理器处于空闲状态，哪些处理器处于繁忙状态。也许一次使用
1024 个处理器会将通向 c -solution 的路径加快 30 倍;值得吗？

这取决于速度和成本之间的权衡。在这种情况下，高度并行版本将比将开放
ubound 最小拆分为三个 ubound
消耗更多的电力。但这很可能是片上并行计算，比片外通信经济得多，因此它可能对总电费增加很少。人等待答案的时间减少则具有可量化的财务价值，这很可能证明处理器内核的额外工作是合理的。

与许多并行方法不同，无论使用多少个处理器，或使用超精细的 ubound
拆分都会产生\ **相同的**\ 最终结果。只有一个c-solution，无论何种方式去测试各自可能性，尝试一切的方法都会找到它。

重点是：在使用 **solveforub**
方法时，可以选择使用并行处理。这是一个可选择的并行级别，因此是进行速度-功耗权衡的简单方法。有时候值得付出更多的总工作量，来提高获取信息的速度。

17.4 通用方程求解器
-------------------

17.4.1 那些通常可以工作的方法
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

一本经典的数值分析书是Forman S. Acton的《Numerical Methods that
Work》。如果你有原版的拷贝，你可以看到标题中有个浮雕的单词“USUALLY”，没有墨水，在“WORK”之前。在重印本中，USUALLY以小字显示，但不是正式标题的一部分。

阿克顿开玩笑的“注意小字印刷”的警告承认了现有数值技术的不令人满意的状态。就像积分例程一样，传统的数值分析教材提供单变量求解方程（求根）的大量方法，并附有这样的建议：“在情况A中使用它，但要小心，因为这样那样可能会出错，然后你应该尝试不同的方法。

.. figure:: assets/image-20230704082834198.png

   image-20230704082834198

目前已有的数值上求解方程 :math:`f(x) = 0` 根的方法通常具有如下缺点：

-  有些需要你选择一个初始的猜测值。如果你猜得不好，你将完全错过你所寻找的根，或者你将无法找到\ *所有的*\ 根。
-  一种方法需要知道或计算函数 f 的导数，但倒数可以可能并非到处都存在。
-  某些方法在函数与 x 轴相交时有效，但当它与 x 轴\ *相切*\ 时不起作用;
   或者它们在理论上工作，但运行速度要慢得多。
-  寻找交叉过零的方法会看不到当函数与 x 轴交叉但又在\ *一个ULP
   的尺度*\ 内穿回的情况。（回想一下第 15.7
   节中描述的“平滑惊喜”的函数)。
-  为\ *不连续*\ 函数寻找零交叉的方法也可能进入死循环迭代，或者错误地认为在它跳过
   x 轴的不连续处必然有一个根。
-  分而治之的方法需要艺术地选择“递归界限”作为停止点，即使极限设置到极高的水平，他们仍然会错过一些根。（同样，第
   15.7 节中的“平滑惊喜”就是这种例子)。
-  任何方法使用浮点数（包括传统的区间算术）时，下溢都可能被误认为根。例如，如果
   f(x)
   是钟形曲线（高斯分布）的公式，则大多数根查找器会错误地将离原点不远的
   x 值 f(x) 当做就是零。

.. raw:: html

   <table border="2">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightblue">

ubox的方程求解/寻根方法不会遗漏任何东西，因为它没有对实数线进行采样;它检查整体，每个值。这是一种（总是，而不是也许）可行的的数值方法

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

而且这种方法也是特别快的因为它可以从极低的精度开始工作，逐渐提升直到在解集上达到任何需要的信息精度。

下面是一些用ubox求根的例子，来演示想击败“尝试所有”的方法有多难。

区间\ :math:`(0, \infty)`\ 可以用{ubitmask, posinfu}表示

.. figure:: assets/image-20230704085710344.png

   image-20230704085710344

说明\ :math:`1/x`\ 在上面区间是有根的。试试Warlpiri unum,
唯一可用的解是\ :math:`\infty`

.. figure:: assets/image-20230704090029236.png

   image-20230704090029236

另外一个例子，
将环境设为足够低，并且问“满足方程\ :math:`sin(x)=1`\ 的x是什么？”。本质上就是问arcsin(1)的值。如果你只需要限制结果在主要范围中，你可以在conditionQ中约束角的范围。下面的代码找到所有的满足解，使用{2,
3}环境。\ |image-20230704090542006|

对于习惯于使用弧度的程序员来说，看到如此简洁、准确的答案可能会令人惊讶。在范围(-maxreal,
maxreal)之间有三个精确的以角度为单位的值满足\ :math:`sin(x)=1`\ 。在这个之外还有无穷多个满足方程的解，函数\ **solveforub**\ 也都找到了并放在左右两个无限长的区间里面。

**读者的练习**\ ：函数\ :math:`sin(\frac{1}{x})`\ 在接近0的附近有无限多个根。使用Warlpiri
unum能产生什么样的ubound可以满足\ :math:`sin(\frac{1}{x})`\ =0?
从\ :math:`[-\infty, \infty]`\ dmain开始找

17.4.2 求逆方法通常会失败
~~~~~~~~~~~~~~~~~~~~~~~~~

本节的开头显示了对线性和二次方程使用求逆方法时会发生什么情况。解三次方程和四次方程也有封闭的形式;而且会是非常复杂的表达式。很长一段时间以来，没有人能弄清楚五次方程的反演公式，人们一直认为这是因为需要去做很多页看起来很糟糕的代数带来的挑战。

大约两百年前，数学家发现了一个证明，证明对于五次或更高的多项式不存在闭式解。“这很好，”你可能会说，“因为我们总是可以使用标准的数值方法来找到根。

事实上不行的。看看下一页的五次多项式的图：

.. figure:: assets/image-20230704103410123.png

   image-20230704103410123

基于浮点数的数值寻根方法在遇到这样的问题时很艰难。即使它们足够复杂，可以处理多阶根（多项式中在
–1 处有一个三重根，在 2 处有一个双根），它们也会错误地将许多接近 –1
和接近 2 的 x 值声明为根，因为下溢为零。

**给读者的练习**\ ：对于 IEEE
单精度，即使多项式计算为完美的浮点精度，上述多项式中 –1 和 2
周围的哪些值范围也会被舍入为零（下溢）？

所以这里既没有逆函数，传统的数值方法给出最多也只能给出很差的答案。那么ubox方法可以解决这个问题吗？试试看

.. figure:: assets/image-20230704105031050.png

   image-20230704105031050

ubox方法对高阶的多项式也是可行的，五阶没有什么特殊，只是一个最低的没有逆公式的多项式而已。如果根无法在计算环境中精确地表达，就返回包含根的最小ULP宽度的unum。

这感觉就像一个进了糖果店的小孩，拥有了这样一个可以很好工作在如此多的场景下的求解器，还不需要什么思考，也不需要背什么求逆的代数公式了。

即使方程\ :math:`f(x)=0`\ 存在求逆公式，有许多函数甚至与多项式并不相似，而且不能对超越函数求逆。

比如这个

.. math::


   log(x)-\frac{1}{x}=0

你如何才能把x全部变换到方程左边呢？没有办法。但是“尝试所有”的方法不需要变换，因为它直接测试方程是否成立。在把上面例子装入\ **solveforub**\ 前，考虑下一种有意思的用NaN的方法。solveforub可以自动算出函数在哪个domain。条件测试是这样：“f的求值会产生NaN吗？”。我们用整个实数区间作为初始

.. figure:: assets/image-20230704110425344.png

   image-20230704110425344

这表明除非x是严格的正数，函数\ :math:`log(x)-\frac{1}{x}`\ 的答案是NaN。这个求解器抓住了0是不允许的，虽然log允许，但是\ :math:`\frac{1}{x}`\ 不可以。

**注意：小心你要的是什么**\ ！solveforub只有当检查到区域的条件是真的才会继续优化，它不对返回假的区域做什么。这是上面这个技巧的作用。如果测试条件是“f
不是NaN”,
如果你在区间{:math:`-\infty, \infty`}做，求解器会立刻返回空集{}，因为测试是False，它就不再进行下去了。这就是为什么测试条件要改为
“f 是 NaN”而不是逆问题。

使用刚才得到的函数的domain :math:`(0, \infty]`,
环境精确到32比特，下面就是设置求解器\ |image-20230704113111216|

得出一个ULP宽度的解，下面用橙色显示数据差别

1.76322283409524883847177734375 < x < 1.7632228345610201358795166015625

有64bit的浮点数可以快速接近到这个根，但是结果不是答案的边界。用IEEE浮点的区间算术可能达到这个精度，但是需要128b来存储这个区间。这里只用了43b.
更少的比特数，更好的答案。

17.4.3 不相等检验;寻找极值
~~~~~~~~~~~~~~~~~~~~~~~~~~

目前所做的测试都相等检验(或者是NaN)，不相等也同样可以检测。类似的需要小心地问问题，如果我们的条件是\ |image-20230704164831076|

那么solveforub方法是不工作的，因为一旦看到一个区域条件是Fail就会停止。给求解器提问题的方式是要条件返回真。所以>3为真其实是说\ **跟区间\ :math:`(3, \infty]`\ 有交就应该返回True**.
而不是有不在的返回False。

.. figure:: assets/image-20230704165332342.png

   image-20230704165332342

这样一开始范围是[:math:`-\infty, \infty`]就会是真，
**solveforub**\ 就开始检查交的区域并且迭代优化子范围。

能做不等式就隐含可以用\ **solveforub**\ 迭代来找到函数某个区域的最大或是最小值。（如果指定的区域是整个实数轴，那么找到的就是全局的最大最小值，而且它还能找到局部极值）。如果寻找函数\ :math:`f(x)`\ 的最大值，初始开始看\ :math:`f(x)>maxreal`\ 条件。如果任何区域可以找到，那么就结束了，这就是可表示的最大值。否则就做二分法，如同\ **splitub**\ 一样。找到最大值的条件

.. figure:: assets/image-20230704174905485.png

   image-20230704174905485

且有答案是非空集合。找最大值需要不超过\ :math:`log_2(n)`\ 次分割。如果unum环境有n个可以表示的值，那么这种方法找最大不超过\ :math:`nlog_2(n)`\ 次函数求值。这可能让让某些读者感到惊讶，以前他们在理论的计算机科学书中看到是寻找一个通用的连续函数的最大最小值是\ **极为困难**\ 的，有句话是说“没有人知道如何快速地做到”。

17.4.4 “棘手”的谬误
~~~~~~~~~~~~~~~~~~~

存在一个定理，它说找到方程根和极值通常是“NP-hard”，这是计算机科学家用来描述\ **没有已知算法只耗费多项式时间就能解的问题**;
也就是说，答案需要指数级的搜索时间，甚至更糟。即使所讨论的函数只是一个多项式，该定理也成立！如果ubox方法使它如此简单，这怎么可能是真的？

上一节展示了一种最多做\ :math:`nlog_2(n)` 次函数计算来查找函数 f
极值的方法，当函数用 unum 数学表示并且有 n 个可能的 unum
值时。这显然不是指数时间。

再回顾检查这个定理，发现它们都是关于数学定义上的“解决”，而不是计算上的定义。谬误有两个方面：假设纯符号数学的困难也一定是数值计算的困难，以及未能意识到用实数计算需要表示范围（开区间）和精确点。ubox
方法不会以代数公式的形式产生“解决方案”，但那又怎样？它总是产生一个答案界限，并且无论出于何种实际目的，都可以根据需要设置该界限严格程度。

.. raw:: html

   <table border="2">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightblue">

Ubox方法将代数问题转换为有限集合问题，然后生成数学上正确的集合声明来表示答案的位置。

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

在“P =
NP？”问题上人们已经做了大量的工作，即NP-hard问题是否与可以在多项式时间内完成的P问题属于一个单独的类。众所周知，如果你不需要对某些NP困难问题有一个完美的答案，而只是保证在答案的百分之几之内，那么是的，一些NP困难问题可以在多项式时间内完成。但这就是实数的实际计算的全部内容：在值的一定距离内，因为大多数实数没有精确的表示。

在估计将 n
个元素按顺序排序所需的时间时也会出现类似的谬误。许多文献断言，对于低效排序（如气泡排序），时间是
:math:`n^2` 阶，对于更复杂的方法（如 HeapSort），时间是 :math:`n log(n)`
阶。这种分析忽略了一个简单的事实，即数字可以表示的不同值数量有限;
只需用直方图，则时间是 n 阶（也称为桶排序）！Ubox
也利用离散值提供的简化。

17.5 大于一维的求解器
---------------------

到目前为止讨论的方法可以推广到多个未知数中的多个方程（或不等式）。part1简要介绍了有两个未知量的两个线性方程的示例。现在我们已经掌握了\ *油漆桶*\ 方法和\ *尝试一切*\ 方法，我们可以在一个简单的系统上试试它们。

比如这个：

.. math::


   \begin{array}{l}
   x+\frac{7}{16}=3 \text{ and } \\
   \frac{7}{8}+y=4
   \end{array}

下面是用矩阵-向量方程来表示同一个问题

.. math::


   \begin{pmatrix}
    1  & \frac{7}{16} \\
   \frac{7}{8}  & 1
   \end{pmatrix}
   \begin{pmatrix}
   x \\
   y
   \end{pmatrix}
   =
   \begin{pmatrix}
   3 \\
   4
   \end{pmatrix}

任何线性方程的系统可以被看做一个点积等式的集合。这个例子我们可以写做
:math:`(1, \frac{7}{16})\cdot \begin{pmatrix} x \\ y \end{pmatrix}=3` 和
:math:`(\frac{7}{8}, 1)\cdot \begin{pmatrix} x \\ y \end{pmatrix}=4`

这是非常重要的，因为点积可以用unum计算环境里的融合计算做到最高精度。

下面是两个方程的系统，作为一个几何问题，是两条直线的交点。

.. figure:: assets/image-20230704193834586.png

   image-20230704193834586

为了更实战且更有挑战性，假设系数不是准确的，而是有一个最小尺寸ULP的不确定性。比如

.. figure:: assets/image-20230704193913674.png

   image-20230704193913674

这使得解集被拓宽成类似于平行四边形，因为现在解交叠的两个区域，那不是真的平行四边形，因为其对边并不平行。

绘制上述系数的高值和低值的每个可能组合会创建一组边界，看起来像有人在 x-y
平面上掉了一些未煮熟的意大利面

.. figure:: assets/image-20230704194346022.png

   image-20230704194346022

一些传统区间算术的倡导者建议弄清楚 16
条线中的哪一条构成了四边形的边界，这是一项非常繁琐的任务，绝对是“NP-hard”的处理方式。

虽然原型不包括 solveforub 搜索函数的二维版本，但使用 ubox 平铺 x-y
平面并测试它们是否符合以下条件并不困难：

.. figure:: assets/image-20230704195202805.png

   image-20230704195202805

其中au是unum的矩阵表示\ :math:`\begin{pmatrix} (1, 1.0625) && (0.4375, 0.5) \\ (0.8125, 0.875) && (1, 1.0625) \end{pmatrix}`,
xu表示未知量 (x, y), bu 表示右边值
:math:`\begin{pmatrix} (3, 3.125) \\ (4, 4.25) \end{pmatrix}`.
用{1，2}环境就足以在不损失的情况下表达所有这些范围。生成二维“尝试一切”ubox测试集的一种简单方法是创建该集的元组
**uboxlist**\ [{:math:`\hat{-\infty}, \hat{\infty}`},
0]。令人惊讶的是结果的fails集是红色，solves集（绿色）则有4个区域。

.. figure:: assets/image-20230704201313546.png

   image-20230704201313546

左上和右下角的solves区域是ubox的扩展区域，跨越\ :math:`(maxreal, \infty)`\ 和(:math:`-\infty, -maxreal`)。两个斜带其实都穿过了该区。这就是17.2.2节显示的二维形式的效果。注意准确的正负无穷是不满足条件的。

在x=(3, 4)和y=(0,
1)的孤立的ubox也穿过了两个斜带，但是他们满血这两个方程的位置点是不同的。

.. figure:: assets/image-20230704202355654.png

   image-20230704202355654

我们应该把这个ubox当做虚假的结果而丢弃吗？这个例子是的。因为我们如果提升精度使得ULP从1变为\ :math:`\frac{1}{2}`,
就会把这个点划掉了。但是如果环境是更粗的比如{0,
1}，那这个ubox就是个合法的c-solution.
当前的环境下这还只是trial的ubox。当然我们感兴趣的还是这个ubox左上方的折叠形状区域。

**请注意，线性方程并没有什么特别之处**\ 。与单变量求解器一样，该方法可以容忍您给它的任何复杂函数，因为无需查找反演公式。你只需要能够使用unum算术陈述你想要满足的条件，计算机就可以（并行）搜索所有候选ubox。

现在考虑油漆桶方法。获得起始种子的一种方法是使用“尝试所有”方法，直到找到在所有维度上都精确的ubox。另一种方法是尝试传统的数值方法，如高斯消除，从不精确的范围内选择精确值：

.. figure:: assets/image-20230704203325891.png

   image-20230704203325891

为了确保我们没有像上面那样的解被单独拐角的情况，请在传统求解器的结果附近选择一对精确的unum，例如表示
2 和 2.25 的
unum。由于浮点数只是猜测，因此仍然需要验证unum对是否满足条件：

.. figure:: assets/image-20230704203506989.png

   image-20230704203506989

我们现在有种子了。在调用油漆桶算法之前，请考虑如果我们尝试使用传统的区间算术和高斯消除会发生什么。

结果如往常一样，很宽松

.. figure:: assets/image-20230704203656379.png

   image-20230704203656379

反演线性方程组的公式，如克莱默规则或高斯消除，多次使用输入值并遇到依赖问题。相比之下，\ **conditionQ**\ 检验中的方程每个输入值使用一次，因此答案没有松散开。

ubox结果已合并在下面的图上。黑点显示单个值，类似于可能由传统数字“求解器”生成的值。但如您所见，当系数不精确时，它只是一个更大集合中的一个值。这就像问“找到x和y使得\ :math:`x^2 + y^2 = 1`”并得到答案“x
= 0，y =
1”句点。我们需要所有有效的值，而不仅仅是一个。单值浮点解隐藏了一些问题的不稳定性;
ubox解将不稳定性暴露为偏心形状的解集，有效地执行“灵敏度分析”，显示不精确的输入如何影响答案。

.. figure:: assets/image-20230704204521628.png

   image-20230704204521628

**灰色**\ 矩形是由使用传统区间算术和高斯消除方法产生的松散边界。虽然松散，但它并非完全无用，因为它可以用作尝试一切搜索的起点，这比从整个
x-y 平面开始搜索更快。

**琥珀**\ 线显示了系数和右侧区间端点的每种组合，其中重叠的确切形状是计算几何中一个指数级困难的问题，它定义了线性系统的最终数学答案。

ubox解和失败求值不需要指数时间，它们在数学上并不完美，但它们像我们要求的那样准确地接近数学答案，并且它们大量使用蛮力并行处理而不是算法复杂性。油漆桶方法比
try-everything
方法具有优势，因为它可以找到满足两个方程的连接点集，并且不包括只有 ubox
的单独部分满足每个方程的 ubox。

17.6 总结ubox求解器方法
-----------------------

俗话说：“如果你不能解决问题，试着重新定义问题。或类似的东西。本章将这一建议更进一步：

.. raw:: html

   <table border="2">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightblue">

.. raw:: html

   <center>

如果你不能解决问题，试着重新定义“解决”的含义。

.. raw:: html

   </center>

.. raw:: html

   <center>

解脱是通过不去做方程的反转，而是提出更简单直接的问题：

.. raw:: html

   </center>

.. raw:: html

   <center>

这些方程在哪里成立？

.. raw:: html

   </center>

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

如果使用尝试一切 ubox
求解器方法有什么棘手之处，那就是确保条件语句提出正确的问题，一个导致细化返回
True 的区域的问题。

向严谨的逻辑学家提问可能会令人恼火。想象一下，在法庭审判中担任证人的人被问到：

   你能分辨出受害者是男人还是女人吗？ 是的。 那么，是男人还是女人？
   是的。 你能告诉我受害者是一个男人吗？ （暂停）是的。
   所以受害者是一个男人。 不。

当律师询问一个非常合乎逻辑思维的证人时，必须非常仔细地提问。试图找到数学方程式的真假也是如此。一旦你问对了问题，真相就会让你不必学习数值计算“秘诀”。计算本身只会花费您有限数量的ubox操作。

.. |image-20230704090542006| image:: assets/image-20230704090542006.png
.. |image-20230704113111216| image:: assets/image-20230704113111216.png
.. |image-20230704164831076| image:: assets/image-20230704164831076.png
