
14 试运行：Unums 面临计算挑战
=============================

.. figure:: assets/image-20230627165205705.png

   image-20230627165205705

..

   .. raw:: html

      <center>

   伯克利教授 William Kahan（威廉.卡汗），IEEE 754 标准的主要架构师。

   .. raw:: html

      </center>

14.1 浮点数II：卡汉之怒
-----------------------

   标题\ *Floating point II: The Wrath of Kahan*\ 是模仿\ `Star Trek II:
   The Wrath of
   Khan <https://en.wikipedia.org/wiki/Star_Trek_II:_The_Wrath_of_Khan>`__

伯克利大学教授威廉·卡汉（William
Kahan）擅长寻找浮点数给出严重错误答案的数学问题的例子……以及提出的替代方案甚至比浮点数更糟糕的例子。
unums能承受Kahan的愤怒吗？ 这是卡汉的例子之一：迭代

.. math::


   U_{i+2} = 111 - \frac{1130}{u_{i+1}} + \frac{3000}{u_i u_{i+1}}

从 :math:`u_0=2、u_1=4` 开始。 使用浮点数时，迭代开始收敛到
6，但随后转向 100，即使 6 是有效的稳态答案。 迭代对于 6
以上的数字是稳定的，但对于 6 以下的数字不稳定。如果数值计算完美，则
:math:`u_i` 值永远不会低于 6；
然而，舍入误差导致它们陷入不稳定区域，然后径直走向
100。下一页的循环使用双精度浮点数显示了这一点：

.. figure:: assets/image-20230627170312618.png

   image-20230627170312618

::

   18.5
   9.37838
   7.80115
   7.15441
   6.80678
   6.59263
   6.44947
   6.34845
   6.27444
   6.21868
   6.17563
   6.13895
   6.06036
   5.1783
   -11.6233
   158.376
   102.235
   100.132

作为浮点替代方案的一个示例，请尝试使用双精度区间算术的迭代循环，该算法每个值消耗
128 位而不是 64 位。它们最好物有所值：

.. figure:: assets/image-20230627170446017.png

   image-20230627170446017

.. figure:: assets/image-20230627170532750.png

   image-20230627170532750

他们\ **不**\ 值得。
这个答案是典型的区间算术：一个正确但无用的结果，表明答案是：\ **实数线上的某个位置**\ 。
现在您可以开始明白为什么区间算术吸引了非常有限的粉丝俱乐部。

现在尝试使用
unums，调高精度（但不是指数，因为这些数字不是特别大或特别小）。
请原谅分数的长小数。 循环后的reportdatamotion 调用报告数据移动成本。

.. figure:: assets/image-20230627181152756.png

   image-20230627181152756

因此 unums 前往正确的数字 6。如果继续前进，左端点将降至 6
以下，然后向\ :math:`-\infty`\ 发散，但请记住，unum 环境可以使用
**needmorefracQ** 自动检测相对宽度何时变得过高，并停止 (
正如我们在这里所做的那样）或提高精度。 Unum
不会像浮点数那样表现出虚假收敛。 此外，它们使用比双精度区间算术（每个值
128 位）更少的位来完成所有这些操作。

许多科学程序员普遍认为以下神话是防范浮点错误危险的简单方法：

.. raw:: html

   <table border="2">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightyellow">

如果您不断增加浮点数的精度，并且答案是一致的，那么答案对于该精度来说是正确的。

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

卡汉构建了以下极其聪明的例子来证明这个神话是多么错误。
对于浮点数，即使精度非常高，您也经常得到 0；

正确答案其实是 1。

定义函数：

-  :math:`E(0)=1`
-  :math:`E(z)=\frac{e^z-1}{z}`
-  :math:`Q[x]=\left|x-\sqrt{x^2+1}\right|-\frac{1}{x+\sqrt{x^2+1}}`
-  :math:`H(x)=E(Q(X))^2`

计算\ :math:`x=15.0, 16.0, 17.0, 9999.0`\ 下的\ :math:`H(x)`\ 的值，换个精度，比如用BigDecimal再做一次看看

“BigDecimal”是 Java
中的一种数据类型，允许扩展精度算术，通过使用大量存储，在用户可见层中允许更多数字来处理舍入误差，这是历史上的众多尝试之一。
卡汉教授确切地知道如何揭露浮点数学的缺陷。 使用双精度浮点数，以下是您对
x 的所有四个建议值得到的错误答案：

.. figure:: assets/image-20230627195316582.png

   image-20230627195316582

即使精度更高，例如 IEEE 四精度或 BigDecimal
扩展精度，它几乎每次仍然会出现错误。 x 的一些分散值给出了正确答案：{1,
1, 1, 1}，可以通过符号而不是数字来计算代数。
关键点是，当答案完全错误时，简单地提高精度并得到相同、完全一致的答案就可能发生。

那么传统的区间运算呢？它应该是“严格的”？
为了给传统区间提供所有可能的优势，我们甚至可以让 Mathematica
以符号方式计算结果，并仅在最后使用数值浮点数对其进行求值，方法是重新定义
e、q 和 h 函数以使用区间算术。 区间为零的测试与我们使用 unums
测试它的方式类似，其中如果零在区间 z 中，则
**IntervalMemberQ**\ [z,\ **Interval**\ [{0,0}]] 为 True，否则为 False：

.. figure:: assets/image-20230627195919811.png

   image-20230627195919811

又一个史诗般的失败。
传统的区间算术再次为您提供整个实数轴作为可能的答案，然后迫使您分析出了什么问题并调试计算丢失所有信息的位置。
此外，与数值计算相比，符号数学的使用极其昂贵且缓慢。
这个例子看起来是一个很难破解的难题！

.. raw:: html

   <table border="2">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightblue">

像本书这样的“戏剧性”时刻并不多，但如果有的话，那就是它了。 unums
能打败卡汉教授的怪物吗？ 也许通过使用一些非常高的环境设置来提高精度。

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

这是函数定义的 unum 版本：

.. figure:: assets/image-20230627200307793.png

   image-20230627200307793

只是为了好玩，我们展示了其中最小、最朴素的 unum，即四位 Warlpiri
number集。 在这场战斗中抱有成功希望的唯一原因是，所有
unum，即使是那些只有一位分数和一位指数的
unum，都正在包装一个强大的武器，这是其他计算数字系统所不具备的：绝对诚实
他们对某个值做了什么和不知道什么。下面就是了

.. figure:: assets/image-20230627200445542.png

   image-20230627200445542

Warlpiri 的数学是正确的，尽管它不能数到超过二！ Unums
用每个数字不到七位的存储空间计算出正确的答案。

.. figure:: assets/image-20230627200608612.png

   image-20230627200608612

14.2 Rump的烦恼事
-----------------

卡汉并不是唯一一个想出办法揭露计算机数字系统缺点的人。 IBM 科学家
Siegfried Rump
提出了一个很好的例子，说明为什么仅仅尝试不同的浮点精度并寻求一致性是不够的

求：

:math:`333.75 y^6 + x^2(11 x^2 y^2 - y^6 -121 y^4 -2)+5.5y^8 + \frac{x}{2y}`

其中 x=77 617, y=33 096

以下是 Rump 的公式和输入参数，以及现代 IEEE 双精度浮点数告诉我们的内容

.. figure:: assets/image-20230627201112787.png

   image-20230627201112787

对于 IEEE 风格的浮点数，Rump
的公式对于单精度、双精度甚至四精度给出了相同的答案，约为
:math:`1.18\times10^{21}`\ ，但在这三种情况下都存在严重错误。 正确答案是
:math:`–0.827\cdots`\ ，因此浮点数甚至无法得到正确答案的符号。
更不用说相差 21 个数量级的小问题了。

Rump 在 1970 年代老式 IBM 大型机上写程序得到该函数的计算结果为 1.172603
单精度， 1.1726039400531双精度 ，以及 1.172603940053178
IBM“扩展”（我们现在称为四元）精度中的 。

IBM 370 浮点格式使用以 16 为基数的指数，并且与现代 IEEE
浮点有其他差异，这就是为什么它会产生如此不同的三个高度一致的结果。
任何试图检查计算可靠性的人都会得出结论：结果是有效的，并且只需要单精度。
请注意，公式中使用的每个数字都可以表示为精确浮点数：333.75, 11, 121, 2,
5.5，并且两个整数输入都是除以 2 的幂的整数，因此在此
情况下，简单地输入问题不会引入任何舍入误差。

如果不是以精确结果的形式呈现，那么偏差 21
个数量级以及符号错误可能会更容易被原谅。
区间算术可以来拯救并保证包含正确的结果吗？ 或许吧。

尝试使用名为 rumpint 的rump版本，它使用 128 位间隔（即每个端点使用 64
位浮点数），至少您会得到答案的界限：

.. figure:: assets/image-20230627202131622.png

   image-20230627202131622

一个巨大的间隔，但也是一个界限。
至少传统的间隔表明rump问题可能容易出现严重错误。
（不幸的是，传统区间也经常暗示着完全稳定的计算。）像往常一样，传统区间结果的巨大宽度让我们对下一步该做什么感到困惑。
尝试使用四精度边界的传统间隔？ 他们也失败了。

用 unum 试试。 因为关于 unums 正在测试的一件事是易用性，所以这里是对
unum 版本的以下代码的一些解释。
:math:`\otimes`\ 运算符优先于\ :math:`\oplus`\ 和\ :math:`\ominus`
运算符，就像传统公式中乘法优先于加法和减法一样，因此我们不必使用括号来编写，例如
:math:`a \otimes b \oplus c \otimes d`\ 。 然而，为了“打破
:math:`x \oplus y \oplus z`\ 之类的表达式的束缚”，我们使用括号从左到右对其进行分组：\ :math:`(x \oplus y) \oplus z`\ 。
在 :math:`\oplus` 和 :math:`\ominus`
运算符周围留出足够的空间也有助于提高可读性。 为了清楚起见，我们为
:math:`x^2、y^2、y^4、y^6 和 y^8` 引入一些临时变量。 **rumpu** 函数使用
ubounds 计算 Rump 的公式：

.. figure:: assets/image-20230627202926314.png

   image-20230627202926314

假设我们希望答案的精度至少达到两位小数，因此我们设置 relwidthtolerance =
0.005。 从 Warlpiri 环境 {0, 0}
开始，让计算机自动查找何时有足够的位来获得可接受的答案，如第 9.3
节所示的流程图。 事实证明，{3, 7}
是获得可接受精度的环境，并且它确实比两位小数要好得多：

.. figure:: assets/image-20230627203053385.png

   image-20230627203053385

unum 方法将答案的精确度限制在 39 位小数，并且每个数字平均使用 70 位。
unums 在这里表现出色的主要原因是它们可以根据需要动态调整精度。
创建表达式的中间结果非常大，需要 37 位小数的精度才能准确表示。
这些小数稍后会在计算中被抵消，从而产生 unum 格式用很少位存储的小整数。
携带 11 位 utag 的开销会带来数倍的回报。
如果我们使用融合运算，每个数字的位数会更低。

.. raw:: html

   <table border="2">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightblue">

.. raw:: html

   <center>

更少的比特，更好的答案

.. raw:: html

   </center>

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

14.3 二次公式
-------------

前面的示例经过精心设计，旨在暴露浮动问题。
读者可能会认为这些示例过于做作，无法反映大多数计算任务，而浮点数似乎做得相当好。
因此，下一个示例展示了一个来自基本主流计算的示例，其中舍入错误会给粗心的程序员带来不愉快的意外。
恰好有一个处理二次公式的特定问题的技巧，并且数值分析书籍热切地告诉您如何调用该技巧，但我们并不是在寻找程序员必须学习的技巧的集合;
计算机应该尽可能多地自动化数值分析。
即使以简单的方式，也就是浮点数通常使用的方式，使用 Unum 也应该可以工作。

二次方程 :math:`a x^2 + b x + c = 0` 的根 :math:`r_1` 和 :math:`r_2`
的公式具有数值风险，我们可以使用它来比较 float 与
unum，无论是为了准确性还是为了存储效率：

.. math::


   r_{1,2}=\frac{-b\pm\sqrt{b^2-4ac}}{2a}

当然，平方根通常会产生不精确的结果。 更微妙的危险是，当 :math:`b^2`
相对于 :math:`4 a c` 太大时，\ :math:`\sqrt{b^2 - 4 a c}` 将与 :math:`b`
共享许多前导数字。 这会导致计算 :math:`-b \pm \sqrt{b2 - 4 ac}`
时出现数字抵消，因为 ± 的 + 或 –
情况都会导致类似数字相减，只留下几个有效数字。

对于 a = 3、b = 100 和 c = 2，请注意有一个根与零有多接近：

.. figure:: assets/image-20230627205308483.png

   image-20230627205308483

以下是两个根的精确表达式，其值精确到小数点后 7 位，供参考：

.. figure:: assets/image-20230627205515718.png

   image-20230627205515718

在IEEE单精度中，b2=100可以精确表示； 4 a c = 24 和 b2 - 4 a c = 9976
也是如此。到目前为止，一切都很好。 9976 的平方根是： 99.8799279…

但是单精度浮点数要求我们接受以下不正确的数字，我们在正确的数字之外使用橙色数字，并在末尾使用“:math:`\downarrow`”符号来强调显示的小数扩展正是该浮点数所表达的精确值：

.. figure:: assets/image-20230627205811300.png

   image-20230627205811300

这肯定在正确平方根的 1 个 ULP 范围内。 问题出现在下一步的计算中，将-b =
-100 添加到上面的数字中。
这样做会消除左边的两个数字，并且错误的橙色数字会放大相对误差：

.. figure:: assets/image-20230627210153376.png

   image-20230627210153376

在最后一步中，除以 2a，我们最终与参考答案只有四位小数一致，结果错误超过
100 个 ULP：

.. figure:: assets/image-20230627210353400.png

   image-20230627210353400

如果计算机跟踪了 ULP
误差是如何放大的，它就会知道将答案表示为“~-0.02001”或只有四位小数的数字。
相反，作为单精度答案，它被欺骗性地显示为“–0.02001190”，没有任何信息让我们知道最后三个看起来精确的小数是错误的。

数值分析书籍中教授的技巧是使用恒等式 r1 r2 = c/a 来求 r1。 由于 r2
不会经历数字抵消，因此精度通常保持不变。
然而，大多数人在学习二次公式后很快就会忘记它的特殊性，并且无论如何，要求程序员记住并应用这样的技巧似乎是不必要的负担。
相反，尝试使用 unum 环境，这是可以模拟单精度浮点数的最小环境：

.. raw:: latex

   \diilbookstyleinputcell

.. code:: mathematica

   setenv[{3, 5}]

这是接近零的根的二次公式的 unum 版本，使用了之前开发的算术运算。
重置移动位数和个数计数器，以便我们可以将每个值的位数与单精度所需的 32
位进行比较：

.. figure:: assets/image-20230627211047288.png

   image-20230627211047288

界限精确到小数点后七位：–0.02001201… {3, 5} unum
环境计算答案中的七个有效小数并严格限制错误，但每个数字使用的平均位数少于
25 位。 因此，在这种情况下，尽管 utag 存在开销，但 unum
提供的精度几乎是标准 IEEE 浮点数的两倍，但使用的位数更少。
当有数字cancel现象时，Unum 存储空间会自动缩小。
如果我们有使用\ **unify**\ 操作的策略，我们可以自动使这变得更加经济。
最终的 87 位 ubound 答案统一为 41 位，即一个 unum：

.. figure:: assets/image-20230627211428316.png

   image-20230627211428316

.. figure:: assets/image-20230627211507319.png

   image-20230627211507319

**unify** 操作仅将边界宽度扩展了约 1.5 倍，同时减少了约 2.1
倍的存储空间，因此在这种情况下，\ **unify** 增加了每比特的信息量。
结果仍然好到小数点后七位。

虽然我们没有在这里展示，但如果将 {3, 6} 环境结果与双精度 IEEE
结果进行比较，unum 会得到 16 位有效数字，而使用双精度则为 12 位，平均
unum 大小为 33 位，而双精度则为 64 位 。
我们\ *以大约一半的位数获得了超过 33% 的准确度*\ 。

这个例子的要点是：\ **不需要任何技巧**\ 。
二次公式示例支持这样的主张：除了比浮点数更准确且使用更少的存储空间之外，unum
还比浮点数更易于使用。 与浮点数相比，unum
的计算更有可能适应程序员想要计算的任何公式，而无需使用代数恒等式对计算进行复杂的重新排列。

.. raw:: html

   <table border="2">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightblue">

.. raw:: html

   <center>

“我们有如此多的数学技巧，以至于我们永远不会停止告诉人们如何做事……物理老师总是展示技术，而不是如何解决物理问题的精神。”
——理查德·费曼

.. raw:: html

   </center>

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

14.4 贝利的数字噩梦
-------------------

David Bailey
是一位数值计算专家，他建立了扩展精度算术库，他提出了一个非常不稳定的系统，该系统由两个未知数的两个方程组成，用作测试：

.. math::


   0.25510582 x + 0.52746197 y = 0.79981812 \\
   0.80143857 x + 1.65707065 y = 2.51270273

这些方程看起来实在是太简单了。
假设可以精确的输入系数的小数，该系统可以精确求解 x = –1 和 y = 2
。我们可以尝试高斯消去法或克莱默法则。
对于这么小的系统，克莱默规则实际上看起来更简单。 回想一下克莱默规则：

.. math::


   \text{解方程 } \left ( \begin{array}{l} ax+by=u \\ cx + dy = v \end{array} \right ) 
   \\ \text{对于x和y，计算分母。 } D=ad-bc \\ \text{ 如果D不为0，那么 } x=\frac{ud-vb}{D} \text{ 且 } y=\frac{av-cu}{D}

从几何角度来说，求解两个未知数的两个方程意味着找到两条线的交点：

.. figure:: assets/image-20230628082834650.png

   image-20230628082834650

行列式D越小，直线越接近平行。 如果 D
恰好为零，则这些线要么是分开的并且从不相交，要么它们可能是同一条线并且到处相交。
假设线条几乎平行，并且输入值 a、b、c、d、u 和 v 中存在一点“摆动”，这是由
±0.5 ULP 的舍入误差引起的。
交点就会到处移动，这意味着问题不稳定：输入的微小变化会导致输出的巨大变化。
在贝利噩梦般的不稳定问题中，精确的确定 D 是

.. math::


   D = 0.25510582 \times 1.65707065 - 0.52746197 \times  0.80143857 \\
     = 0.4227283669661830 - 0.4227283669661829 \\
     = 0.0000000000000001 = 10^{-16}

行列式不为零，但它很小，即使输入中 0.5 ULP 摆动也会导致答案与答案 x =
-1, y = 2 发生约 ±1 亿的变化。行列式很小没有问题 只要是准确的；
但因为这里是通过减去非常相似的浮点值来计算的，因此计算中的不准确性被放大，包括从十进制输入到二进制格式的转换。

由于 IEEE 双精度能够达到几乎 16 位小数精度，而输入只有 8 或 9
位小数，因此它似乎可以做到这一点。 **但是它失败了**\ 。
当您使用双精度和克莱默规则时，减法会导致大量有效数字丢失。
行列式应该正好是 10-16：

.. math::


   det = 0.25510582 \times 1.65707065 - 0.52746197 \times 0.80143857

:math:`1.66533 \times 10^{-16}`

行列式不为零，因此通过克莱默法则计算 x 和 y：

.. math::


   {\begin{array}{l}
   (0.79981812 \times 1.65707065 - 2.51270273 \times .52746197) \div det \\
   (0.25510582 \times 2.51270273 - .80143857 \times 0.79981812) \div det
   \end{array}}

:math:`\{ 0., 1.33333 \}`

该答案与正确答案 {x, y} = {-1, 2} 没有任何相似之处。
至此，读者不会感到非常惊讶，尽管使用两倍的位数来表示数字，但双精度区间算术也会失败。
x 和 y 的计算结果均为 :math:`[-\infty, \infty]`\ （采用传统间隔）

与所有输入值都可以用浮点数精确表达的 Rump 问题不同，Bailey
问题有两个错误来源：将十进制输入转换为二进制浮点数，以及中间结果的精度不足。
我们可以将这两种效果分开。
要求程序员知道这个理论知识并不过分：那就是任何线性系统可以进行缩放而答案不改变。
由于浮点数可以精确地表示整数范围，因此只需将问题缩放 :math:`10^8`
以使所有值都为整数，然后重试：

.. math::


   det = 25 510 582. \times 165 707 065. - 52 746 197. \times 80 143 857.

:math:`1.`

这次行列式被精确地计算出来了。 这样就消除了小数到浮点转换的问题。
所以，砥砺前行：

.. figure:: assets/image-20230628085625387.png

   image-20230628085625387

x 仍然是错的，但至少 y 是对的。 x
中的误差是由于第二个缺点，即中间结果的精度不够。 问题是浮点仅表达精确到
ULP 变为宽度 2 而不是宽度 1 的大小的整数。第一个乘法
:math:`79981812 \times 165707065` 应该是

   .. raw:: html

      <center>

   13 253 551 319 901 780

   .. raw:: html

      </center>

这恰好可以用双精度表示，因为它是偶数。而乘积\ :math:`251270273 \times 52746197`\ 结果应该是

   .. raw:: html

      <center>

   13 253 551 319 901 781

   .. raw:: html

      </center>

但该整数无法表达，因此它会向下舍入到最接近的偶数，从而使两个乘积之间的差值为
0 而不是 -1。

Bailey 认为供应商应该开始在硬件中支持四精度 IEEE
浮点，以便更容易解决此类问题。 Unums
指出了一种不同的方法，这种方法不要求程序员为了得到像 –1 和 2
这样的答案而使用 34 位十进制值：而是要\ **依靠暂存器**\ 。 像
:math:`u d - v b`
这样的克莱默规则计算的值只是点积，并且融合点积仅在所有乘积累加后才进行舍入。
不要采用四精度，而是采用另一种方式：使用 {3, 5}, 环境，可以模拟 IEEE
单精度。 输入值是可以精确表示的。
通过在原型中使用融合点积，程序员不必担心中间计算占用更多空间。

.. figure:: assets/image-20230628090316194.png

   image-20230628090316194

这就可以了，用了不到不准确的双精度解决方案所使用的一半的位数，就得到了计算准确的答案。
讽刺的是，现在可以使用最原始的 unum 环境来存储 Bailey
的苛刻问题的答案，因为全零 utag 左侧的 101 始终代表 –1，而全零 utag
左侧的 010 始终代表 2。

这里的教训是，所选环境至少最初应与输入值精度和要求输出值的精度相匹配，而
g-layer可以处理临时更精确的临时计算的需要。 在第 2
部分中，我们将探索一种技术，当输入值是范围而不是精确值时，该技术可以自动找到两个未知数中的两个方程问题的完整解集。
当问题不适定时，就像贝利的问题一样，这种技术会可以立即将其暴露出来。

14.5 使用unum做快速傅里叶变换
-----------------------------

.. figure:: assets/image-20230628092444476.png

   image-20230628092444476

..

   石油和天然气矿床的勘探是通过巨大的地震探测器阵列来完成的，这些探测器记录强声脉冲的回声。
   这可能是最古老的“大数据”问题，因为记录下来进行处理的比特还真是通过卡车运回的。
   勘探行业长期以来一直在努力使数据移动和存储更加经济。 Unum
   是做到这一点的关键，特别是可以减少最重要的内核信号处理的数据移动成本：快速傅里叶变换。

本节涉及一些相当高阶的数学，因此请将其视为可选读。
信号处理是计算机最重要的用途之一，也是 unum 可以发挥特别作用的领域。
信号处理硬件在消费电子产品中无处不在，它可以改善相机和电视图像，为音频播放器编码和播放声音，甚至控制汽车系统。
数字信号处理以及一般科学和工程中最重要的运算之一是傅里叶变换。
如果您听到一个音乐和弦并且有足够好的耳朵来辨别各个音符，那么您所做的就是傅立叶变换的作用。
它将信号或任何函数转换为不同频率和幅度的正弦和余弦函数。
傅里叶逆变换将频率分量表示转换回原始信号。

计算离散输入数据的傅里叶变换的常用方法是所谓的快速傅里叶变换（简称
FFT）的某种变体。 对于具有 n 个数据点的信号，FFT 算法会通过大约 $5 n
log_2(n) $次浮点运算生成傅立叶变换。
在现代计算机上，性能受到严重限制的不是算术量，而是移动数据的需要。
如果我们可以安全地减少操作数中的位数，例如使用
unum，我们可以按比例运行得更快，而且我们还可以得到正确的答案范围。

许多信号信息来自仅精确到几个位的模数转换器。 目前声音编码的标准是每通道
16 位精度，但对于许多应用（如石油勘探）来说，数据只有 12
位精度（相当于大约 3.6 位十进制数字）。
如果您查看音响设备上的图形均衡器（或音乐软件显示的图形均衡器），您会看到傅里叶变换的作用。
它们连续实时计算从最低（低音）到最高（高音）的频率强度：

.. figure:: assets/image-20230628093502627.png

   image-20230628093502627

假设信号范围从 –8 到 8，并且只有 12 或 16 位小数。
在这种情况下，我们需要的只是一个小的 unum
标签来表示模数转换器可以提供的所有内容：

.. figure:: assets/image-20230628093543465.png

   image-20230628093543465

信号处理的标准基准测试长期以来一直是“1K CFFT”，即 1024
点复快速傅里叶变换。 下一页是该算法的简单通用长度版本，用于比较浮点数与
unum。 像 gg 和 ww 这样的双字母变量是 :math:`a + bi` 形式的复数。

.. figure:: assets/image-20230628093724725.png

   image-20230628093724725

如果输入数据只有 12 到 16 个有效位，为什么不简单地使用 IEEE
半精度浮点数来节省存储空间呢？ 原因之一是 IEEE 半精度有 10
位小数，这还不够。 另一个原因是三角函数，对于 n 点 FFT，在 n
个位置对单位圆进行采样。 假设 n = 1024； :math:`\frac{2 \pi}{1024}`
的余弦为 0.999981175 ，但是用10 位小数则四舍五入为数字 1。
:math:`2 \pi \times \frac{ 2}{1024}` 和
:math:`2 \pi \times \frac{3}{1024}` 也类似。
显然，一些重要的东西会因为精度太低而被丢弃。
因此，尽管输入数据的精度较低，但信号处理长期以来一直使用单精度浮点数来完成。
一种方式理解傅里叶变换的方式是把它视为波的和。
下面是一个具有两个波频率的 1024 点 FFT，实部显示为蓝色，虚部显示为紫色。

上述 FFT 代码的 unum 版本在附录 C.17 中。
与本章前面的示例不同，此计算涉及数万次计算，并为比较 unum 和 float
的存储效率提供了最佳基础。 首先，对答案进行健全性检查；
这是相同变换的图，但使用 unum 算术并跟踪位和个数的搬运量。

.. figure:: assets/image-20230628102943094.png

   image-20230628102943094

两个结果之间的差异远低于图表的分辨率； unum
版本中的边界宽度太小，在图中也看不到。 检查数据移动成本：

.. figure:: assets/image-20230628103711078.png

   image-20230628103711078

utag 只有 6 位长，最大 unum 大小为 25 位。 由于 FFT
中算术的许多或大部分结果都是
ubound，并且旋转因子引入了无理数，通常需要使用最大小数位数表示，因此您可能会以为每个数字的平均位数非常接近
ubound 有两个元素，即 51 位。 为什么每 ubound 使用的比特数少于 23
位？效果如此之好是怎么做到的。

大部分答案可以在 FFT
内核运算中找到，由于其数据流图的形状，有时被称为“蝶形运算”：

.. figure:: assets/image-20230628105422834.png

   image-20230628105422834

..

   .. raw:: html

      <center>

   “w”是“旋转因子”，对应于上述算法中的旋转

   .. raw:: html

      </center>

假设 u 和 v 是 12 位整数，即 0 到 4095 之间的数字。在最上面的情况下，将
u 和 v 相加可能会导致整数溢出。 我们可能需要 13 位来准确表示总和。
在下面的情况下，我们从 u 中减去 v，这通常需要少于 12 位。
该算法实际上要求位级的灵活精度，因为固定大小的分数在一种情况下可能会出现舍入错误，而在另一种情况下可能会浪费存储空间。
unum 环境根据需要提升和降低精度，但仅此而已。

FFT 提供了尝试 **smartunify** 的机会。 原型 unum 函数使用目标比率为 1 的
**smartunify**\ ，因此只有在增加每比特信息时才unify 含2部分的ubound。
如果不用它，前面 1K FFT 的成本将上升到每个值 28.5 位。
如图所示，边界的轻微放松对最终结果的影响可以忽略不计；
此外，unify后的答案仍然是有正确边界的，而不是像浮点计算那样的属于猜测。

石油和天然气行业长期以来一直依赖 32 位浮点来保护 12 位数据的中间计算，但
unum 方法提供了可证明正确的有界结果，每个数字的位数更少。
一旦用户对最终结果需要多少精度做出让步，根据应用的不同，还可以实现更大的节约。
