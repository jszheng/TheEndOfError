<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    
    <title>20 二体问题(以及多体问题) &#8212; THE END of ERROR - Unum Computing 0.1 documentation</title>

    <link rel="stylesheet" href="_static/material-design-lite-1.3.0/material.blue-deep_orange.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/sphinx_materialdesign_theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/fontawesome/all.css" type="text/css" />
    <link rel="stylesheet" href="_static/fonts.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="_static/d2l.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/d2l.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="21 微积分被认为是邪恶的：离散物理" href="21_calculus_evil.html" />
    <link rel="prev" title="19 摆的正确计算" href="19_pendulums_done_correctly.html" /> 
  </head>
<body>
    <div class="mdl-layout mdl-js-layout mdl-layout--fixed-header mdl-layout--fixed-drawer"><header class="mdl-layout__header mdl-layout__header--waterfall ">
    <div class="mdl-layout__header-row">
        
        <nav class="mdl-navigation breadcrumb">
            <a class="mdl-navigation__link is-active">20 二体问题(以及多体问题)</a>
        </nav>
        <div class="mdl-layout-spacer"></div>
        <nav class="mdl-navigation">
        
<form class="form-inline pull-sm-right" action="search.html" method="get">
      <div class="mdl-textfield mdl-js-textfield mdl-textfield--expandable mdl-textfield--floating-label mdl-textfield--align-right">
        <label id="quick-search-icon" class="mdl-button mdl-js-button mdl-button--icon"  for="waterfall-exp">
          <i class="material-icons">search</i>
        </label>
        <div class="mdl-textfield__expandable-holder">
          <input class="mdl-textfield__input" type="text" name="q"  id="waterfall-exp" placeholder="Search" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </div>
      </div>
      <div class="mdl-tooltip" data-mdl-for="quick-search-icon">
      Quick search
      </div>
</form>
        
<a id="button-show-source"
    class="mdl-button mdl-js-button mdl-button--icon"
    href="_sources/20_two_body_problem.rst.txt" rel="nofollow">
  <i class="material-icons">code</i>
</a>
<div class="mdl-tooltip" data-mdl-for="button-show-source">
Show Source
</div>
        </nav>
    </div>
    <div class="mdl-layout__header-row header-links">
      <div class="mdl-layout-spacer"></div>
      <nav class="mdl-navigation">
          
              <a  class="mdl-navigation__link" href="https://github.com/jszheng/TheEndOfError">
                  <i class="fab fa-github"></i>
                  Github
              </a>
      </nav>
    </div>
</header><header class="mdl-layout__drawer">
    
          <!-- Title -->
      <span class="mdl-layout-title">
          <a class="title" href="index.html">
              <span class="title-text">
                  THE END of ERROR - Unum Computing
              </span>
          </a>
      </span>
    
    
      <div class="globaltoc">
        <span class="mdl-layout-title toc">Table Of Contents</span>
        
        
            
            <nav class="mdl-navigation">
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Preface.html">Preface</a></li>
<li class="toctree-l1"><a class="reference internal" href="00_how_to_read.html">如何读这本书</a></li>
<li class="toctree-l1"><a class="reference internal" href="Part1.html">Part 1 一种新的数字格式Unum</a></li>
<li class="toctree-l1"><a class="reference internal" href="01_Overview.html">1 概论</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_BuildUpUnumFormat.html">2. 构造unum的格式</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_TheOriginalSin.html">3. 计算机算术的原罪</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_unum_format.html">4. 完整的unum格式定义</a></li>
<li class="toctree-l1"><a class="reference internal" href="05_hidden_scratchpads_3_layers.html">5. 隐藏的草稿本和三个层次</a></li>
<li class="toctree-l1"><a class="reference internal" href="06_info_per_bit.html">6 每个比特的信息</a></li>
<li class="toctree-l1"><a class="reference internal" href="07_fixed_size_unum_storage.html">7 定长的unum存储</a></li>
<li class="toctree-l1"><a class="reference internal" href="08_comparison_operations.html">8 比较操作</a></li>
<li class="toctree-l1"><a class="reference internal" href="09_add_sub_unbias_round.html">9 加减法和无偏差舍入的迷</a></li>
<li class="toctree-l1"><a class="reference internal" href="10_mul_div.html">10 乘法和除法</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_power.html">11 求幂</a></li>
<li class="toctree-l1"><a class="reference internal" href="12_other_important_unary_ops.html">12 其他重要的一元运算</a></li>
<li class="toctree-l1"><a class="reference internal" href="13_fused_operations.html">13 融合操作（一次性表达式）</a></li>
<li class="toctree-l1"><a class="reference internal" href="14_trial_runs.html">14 试运行：Unums 面临计算挑战</a></li>
<li class="toctree-l1"><a class="reference internal" href="part1_summary.html">小结</a></li>
<li class="toctree-l1"><a class="reference internal" href="Part2.html">Part 2 - 一种新的解决方法 Ubox</a></li>
<li class="toctree-l1"><a class="reference internal" href="15_TheOtherKindOfError.html">15. 另外一种误差</a></li>
<li class="toctree-l1"><a class="reference internal" href="16_avoid_interval_arith_pitfalls.html">16 避免区间算术陷阱</a></li>
<li class="toctree-l1"><a class="reference internal" href="17_meaning_of_solve_equ.html">17 “解”方程到底是什么意思？</a></li>
<li class="toctree-l1"><a class="reference internal" href="18_permission_to_guess.html">18 准许猜测</a></li>
<li class="toctree-l1"><a class="reference internal" href="19_pendulums_done_correctly.html">19 摆的正确计算</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">20 二体问题(以及多体问题)</a></li>
<li class="toctree-l1"><a class="reference internal" href="21_calculus_evil.html">21 微积分被认为是邪恶的：离散物理</a></li>
<li class="toctree-l1"><a class="reference internal" href="22_end_of_error.html">22 错误的终结</a></li>
<li class="toctree-l1"><a class="reference internal" href="Glossary.html">词汇表</a></li>
</ul>

            </nav>
        
        </div>
    
</header>
        <main class="mdl-layout__content" tabIndex="0">

	<script type="text/javascript" src="_static/sphinx_materialdesign_theme.js "></script>
    <header class="mdl-layout__drawer">
    
          <!-- Title -->
      <span class="mdl-layout-title">
          <a class="title" href="index.html">
              <span class="title-text">
                  THE END of ERROR - Unum Computing
              </span>
          </a>
      </span>
    
    
      <div class="globaltoc">
        <span class="mdl-layout-title toc">Table Of Contents</span>
        
        
            
            <nav class="mdl-navigation">
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Preface.html">Preface</a></li>
<li class="toctree-l1"><a class="reference internal" href="00_how_to_read.html">如何读这本书</a></li>
<li class="toctree-l1"><a class="reference internal" href="Part1.html">Part 1 一种新的数字格式Unum</a></li>
<li class="toctree-l1"><a class="reference internal" href="01_Overview.html">1 概论</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_BuildUpUnumFormat.html">2. 构造unum的格式</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_TheOriginalSin.html">3. 计算机算术的原罪</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_unum_format.html">4. 完整的unum格式定义</a></li>
<li class="toctree-l1"><a class="reference internal" href="05_hidden_scratchpads_3_layers.html">5. 隐藏的草稿本和三个层次</a></li>
<li class="toctree-l1"><a class="reference internal" href="06_info_per_bit.html">6 每个比特的信息</a></li>
<li class="toctree-l1"><a class="reference internal" href="07_fixed_size_unum_storage.html">7 定长的unum存储</a></li>
<li class="toctree-l1"><a class="reference internal" href="08_comparison_operations.html">8 比较操作</a></li>
<li class="toctree-l1"><a class="reference internal" href="09_add_sub_unbias_round.html">9 加减法和无偏差舍入的迷</a></li>
<li class="toctree-l1"><a class="reference internal" href="10_mul_div.html">10 乘法和除法</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_power.html">11 求幂</a></li>
<li class="toctree-l1"><a class="reference internal" href="12_other_important_unary_ops.html">12 其他重要的一元运算</a></li>
<li class="toctree-l1"><a class="reference internal" href="13_fused_operations.html">13 融合操作（一次性表达式）</a></li>
<li class="toctree-l1"><a class="reference internal" href="14_trial_runs.html">14 试运行：Unums 面临计算挑战</a></li>
<li class="toctree-l1"><a class="reference internal" href="part1_summary.html">小结</a></li>
<li class="toctree-l1"><a class="reference internal" href="Part2.html">Part 2 - 一种新的解决方法 Ubox</a></li>
<li class="toctree-l1"><a class="reference internal" href="15_TheOtherKindOfError.html">15. 另外一种误差</a></li>
<li class="toctree-l1"><a class="reference internal" href="16_avoid_interval_arith_pitfalls.html">16 避免区间算术陷阱</a></li>
<li class="toctree-l1"><a class="reference internal" href="17_meaning_of_solve_equ.html">17 “解”方程到底是什么意思？</a></li>
<li class="toctree-l1"><a class="reference internal" href="18_permission_to_guess.html">18 准许猜测</a></li>
<li class="toctree-l1"><a class="reference internal" href="19_pendulums_done_correctly.html">19 摆的正确计算</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">20 二体问题(以及多体问题)</a></li>
<li class="toctree-l1"><a class="reference internal" href="21_calculus_evil.html">21 微积分被认为是邪恶的：离散物理</a></li>
<li class="toctree-l1"><a class="reference internal" href="22_end_of_error.html">22 错误的终结</a></li>
<li class="toctree-l1"><a class="reference internal" href="Glossary.html">词汇表</a></li>
</ul>

            </nav>
        
        </div>
    
</header>

    <div class="document">
        <div class="page-content" role="main">
        
  <div class="section" id="id1">
<h1>20 二体问题(以及多体问题)<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h1>
<div class="figure align-default" id="id11">
<img alt="_images/image-20230707145046785.png" src="_images/image-20230707145046785.png" />
<p class="caption"><span class="caption-number">Fig. 375 </span><span class="caption-text">image-20230707145046785</span><a class="headerlink" href="#id11" title="Permalink to this image">¶</a></p>
</div>
<blockquote>
<div><p>2013 年 2 月，在可能发生碰撞十一个月前, 观星者发现了一颗 60
米长的小行星正向地球飞去。美国宇航局专家戴维·邓纳姆 (David Dunham)
表示：“<em>地球引力场将显着改变小行星的路径。
需要进一步仔细计算来估计碰撞的威胁。</em>”
使用容易出错的浮点数和传统时间步长方法计算这个二体问题只能提供猜测，而不能严格保证小行星不会撞击地球，带来热核武器一样的破坏。最终它从几千英里外略过地球。</p>
<p>请原谅上图艺术化地展示流星热量引发的光芒；其实只有当它撞击大气层时才会发生这种情况。</p>
</div></blockquote>
<div class="section" id="id2">
<h2>20.1 多维微分方程<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h2>
<p>“双体问题”一词被用来开玩笑，指的是夫妻有时在同一地区寻找职业的困难，尤其是当两个人都在学术界时。
这个笑话现在如此普遍，以至于它可能是“二体问题”一词最常见的用法。
在这里，我们只关心该短语适用于牛顿物理学的情况。</p>
<p>计算 N
个质点的集合如何在经典引力作用下移动的问题已经存在了数百年，并且路径形状始终可以用初等函数表示的唯一情况是当
<span class="math notranslate nohighlight">\(N = 2\)</span> 时。
当质点遵循圆锥曲线的路径时：椭圆、抛物线、双曲线，二体问题就解决了。
由于我们知道路径形状的初等函数，因此我们可以针对该精确解来测试任何数值方法。</p>
<p>然而，读者可能会惊讶地发现，轨迹没有基本函数，即两个质点随时间变化的函数。
与钟摆问题一样，轨迹公式也被表达为基本函数的无限组合，这让我们想知道数值方法是否可以给出更实际的答案，即用数值来表示质点的位置和时间。</p>
<p>与钟摆问题一样，大多数物理教科书都对二体问题进行了微妙的修改，以使方程看起来更漂亮，即使这意味着它们是错误的。
大多数物理学家所达到的第一个近似是“假设一个质量比另一个质量大得多，并且可以被视为静止的。”
我们不会在这里这样做。
比如说，在地球绕太阳运行的情况下，太阳的质量大约是地球的 300000
倍，这似乎是合理的。 但请注意，如果该近似值导致计算结果偏离 30
万分之一，则地球位置将偏离近 300 英里！</p>
<p>目前我们允许的一种近似是，动力学是直接的牛顿物理学，没有时空相对论弯曲的影响。
在我们的太阳系中，广义相对论对行星轨道的影响是如此微小，以至于需要几个世纪的时间才能变得足够大以供观察。</p>
<div class="section" id="id3">
<h3>20.1.1 设置传统模拟<a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h3>
<p>首先尝试传统的数值时间步进方法。
在解释物理方程时，很容易陷入变量名称和定义中，因此这里将尽一切努力将变量的数量保持在最低限度。
下标也很难阅读，例如“<span class="math notranslate nohighlight">\(v_x\)</span>”表示“x
方向的速度”，因此我们使用的唯一下标将是零，例如“<span class="math notranslate nohighlight">\(x_0\)</span>”表示初始值，或“new”，例如“
<span class="math notranslate nohighlight">\(y_{new}\)</span>”表示根据先前值计算的值。
否则，我们尝试使用单个字母来表示物理量。
为了简化让轨道始终位于相对于质心的平面上，这样我们只需要使用两个维度进行实验，x
和 y。 速度也有 x 和 y 分量，我们称为 u 和 v。加速度分量称为 a 和 b。</p>
<p>假设两个质点为 M = 8 和 m = 1。“平方反比”力定律表明质量受到
<span class="math notranslate nohighlight">\(\frac{G M m}{r^2}\)</span> 的力，其中 r 是质量中心之间的距离，G
是万有引力常数。
我们在这里不使用米或秒等标准单位，因此假设在某些单位制中重力常数为 G =
2.25。 在初始位置 <span class="math notranslate nohighlight">\((x_0, y_0)=(4, 0)\)</span> 和初始速度
<span class="math notranslate nohighlight">\((u_0, v_0) = (0, 2.25)\)</span> 处启动较轻的质量 m。
（选择这些数字是为了使图形清晰；G 和初始值 <span class="math notranslate nohighlight">\(v_0\)</span>
最终都是相同的数字，这只是巧合，<span class="math notranslate nohighlight">\(2.25 = \frac{9}{4}\)</span>。）用计算机术语来说：</p>
<div class="figure align-default" id="id12">
<img alt="_images/image-20230709103942136.png" src="_images/image-20230709103942136.png" />
<p class="caption"><span class="caption-number">Fig. 376 </span><span class="caption-text">image-20230709103942136</span><a class="headerlink" href="#id12" title="Permalink to this image">¶</a></p>
</div>
<p>质点 M 的位置和速度就是 m 的位置和速度按 <span class="math notranslate nohighlight">\(-\frac{m}{M}\)</span>
缩放，因此质心位于原点，总动量为零。
这使我们不必使用更多的变量名，因为我们只需要遵循 m 的行为。 M
的行为关于原点点对称，按比例缩放：</p>
<div class="figure align-default" id="id13">
<img alt="_images/image-20230709104312284.png" src="_images/image-20230709104312284.png" />
<p class="caption"><span class="caption-number">Fig. 377 </span><span class="caption-text">image-20230709104312284</span><a class="headerlink" href="#id13" title="Permalink to this image">¶</a></p>
</div>
<p>模拟中变化的量是位置、速度和加速度。
通常的方法采用时间步长：使用位置来查找加速力，计算出时间步长后质量的位置，更新新时间的位置和速度，然后重复。
对于动力学问题，这是最简单的传统数值技术，即欧拉方法。</p>
<p>质量 m 是距原点的距离 <span class="math notranslate nohighlight">\(\sqrt{x^2 + y^2}\)</span>，但质量 M 距离原点更近
<span class="math notranslate nohighlight">\(\frac{m}{M}\)</span> 倍。 这意味着质量之间的总距离 <span class="math notranslate nohighlight">\(r\)</span> 为
<span class="math notranslate nohighlight">\(r = (1 + \frac{m}{M})\sqrt{x^2 + y^2}\)</span> ，有时更容易写为
<span class="math notranslate nohighlight">\(\frac{M+m}{M}\sqrt{x^2 + y^2}\)</span> 。 像 <span class="math notranslate nohighlight">\(\frac{M+m}{M}\)</span>
这样的表达式的出现是我们只跟踪质量 m 的运动所付出的代价。
它们可能会变得复杂，但至少只有 m、M 和 G
的表达式在整个经典动力学计算中不会改变，因此只需在开始时计算它们。
表达式 <span class="math notranslate nohighlight">\(\frac{G M^33}{(M+m)^2}\)</span>
出现的频率足够高，因此我们将其命名为 <strong>Gm</strong>。 质点m上的加速度在此由
<strong>acc[{x,y}]</strong> 函数计算：</p>
<div class="figure align-default" id="id14">
<img alt="_images/image-20230709105137114.png" src="_images/image-20230709105137114.png" />
<p class="caption"><span class="caption-number">Fig. 378 </span><span class="caption-text">image-20230709105137114</span><a class="headerlink" href="#id14" title="Permalink to this image">¶</a></p>
</div>
<p>例如，初始加速度在 x 方向上向左（负），并且在 y
方向上没有初始加速度，因为质点都是从相同的 y 位置开始：</p>
<div class="figure align-default" id="id15">
<img alt="_images/image-20230709105308345.png" src="_images/image-20230709105308345.png" />
<p class="caption"><span class="caption-number">Fig. 379 </span><span class="caption-text">image-20230709105308345</span><a class="headerlink" href="#id15" title="Permalink to this image">¶</a></p>
</div>
<p>在瞬时加速度的数值计算中已经出现了小的舍入误差。 <strong>acc</strong>
计算不太可能精确浮点数。</p>
<p>接下来发生采样误差（并且比舍入误差大得多），因为时间步是时间间隔，而不是时间瞬间。
有大量关于在时间步中更新位置的最佳方法的文献，但假设您不想进行大量阅读，而只是尝试应用有关对象如何移动的第一原理，例如古老的
<span class="math notranslate nohighlight">\(F = m a\)</span> 。 加速度是速度随时间的变化，因此在时间 t
之后更新速度非常简单：</p>
<div class="figure align-default" id="id16">
<img alt="_images/image-20230709105617477.png" src="_images/image-20230709105617477.png" />
<p class="caption"><span class="caption-number">Fig. 380 </span><span class="caption-text">image-20230709105617477</span><a class="headerlink" href="#id16" title="Permalink to this image">¶</a></p>
</div>
<p>显然，是的，但请想一想：时间步内 x 和 y 的加速度是多少？ 加速度与根据
<span class="math notranslate nohighlight">\(x_0\)</span> 和 <span class="math notranslate nohighlight">\(y_0\)</span> 计算的 a 和 b
的初始值不同（如上所示），因为质量改变了位置。
这就是采样误差：我们使用时间步开始时的加速度作为整个时间步的加速度的替代值。
时间步长越大，在假装像加速度这样的变化量为常数时，采样误差就越大。</p>
<p>同样，更新位置计算如下</p>
<div class="figure align-default" id="id17">
<img alt="_images/image-20230709105908053.png" src="_images/image-20230709105908053.png" />
<p class="caption"><span class="caption-number">Fig. 381 </span><span class="caption-text">image-20230709105908053</span><a class="headerlink" href="#id17" title="Permalink to this image">¶</a></p>
</div>
<p>这些是恒定加速度轨迹的精确方程，因此我们可以使用计算机拼凑出轨迹的良好近似值来对下一个时间步进行更新，这似乎是完全合理的。
尝试计算机可以表示而没有舍入误差的时间步长，例如 t =
0.5，并使用上面的公式计算新的位置和速度：</p>
<div class="figure align-default" id="id18">
<img alt="_images/image-20230709110041012.png" src="_images/image-20230709110041012.png" />
<p class="caption"><span class="caption-number">Fig. 382 </span><span class="caption-text">image-20230709110041012</span><a class="headerlink" href="#id18" title="Permalink to this image">¶</a></p>
</div>
<p>动能仅取决于速度。 势能仅取决于位置。 由于每个质点的动能为
<span class="math notranslate nohighlight">\(\frac{1}{2} mass \times velocity^2\)</span>，整个系统的势能为
<span class="math notranslate nohighlight">\(-\frac{G M m}{r}\)</span>，因此您可以将总能量表示为常数乘以
<span class="math notranslate nohighlight">\(u^2 + v^2\)</span>（动能部分）与常数乘以
<span class="math notranslate nohighlight">\(\frac{1}{\sqrt{x^2+y^2}}\)</span>之和。（势能部分）：</p>
<div class="figure align-default" id="id19">
<img alt="_images/image-20230709110530554.png" src="_images/image-20230709110530554.png" />
<p class="caption"><span class="caption-number">Fig. 383 </span><span class="caption-text">image-20230709110530554</span><a class="headerlink" href="#id19" title="Permalink to this image">¶</a></p>
</div>
<p>该公式的计算机版本将允许我们监控模拟中任意点的系统状态能量 e：</p>
<div class="figure align-default" id="id20">
<img alt="_images/image-20230709110617878.png" src="_images/image-20230709110617878.png" />
<p class="caption"><span class="caption-number">Fig. 384 </span><span class="caption-text">image-20230709110617878</span><a class="headerlink" href="#id20" title="Permalink to this image">¶</a></p>
</div>
<p>物理学告诉我们系统中的总能量应该是恒定的。
应该是这样，但对于浮点算术和传统的数值方法来说，就不会了。
对于这些初始条件，它从以下值开始：</p>
<div class="figure align-default" id="id21">
<img alt="_images/image-20230709110709946.png" src="_images/image-20230709110709946.png" />
<p class="caption"><span class="caption-number">Fig. 385 </span><span class="caption-text">image-20230709110709946</span><a class="headerlink" href="#id21" title="Permalink to this image">¶</a></p>
</div>
<p>总能量的负值告诉我们轨迹是束缚轨道（椭圆）；
正总能量表示无束缚轨迹（双曲线）。 检查一个时间步后的总能量：</p>
<div class="figure align-default" id="id22">
<img alt="_images/image-20230709110813734.png" src="_images/image-20230709110813734.png" />
<p class="caption"><span class="caption-number">Fig. 386 </span><span class="caption-text">image-20230709110813734</span><a class="headerlink" href="#id22" title="Permalink to this image">¶</a></p>
</div>
<p>这甚至不是恒定到小数点后一位。 另一个应该守恒的量是角动量，它与叉积
<span class="math notranslate nohighlight">\(x v - y u\)</span> 成正比。 它一开始等于 9，我们将其保存在 cross0 中。
检查时间步之后它与保持恒定的接近程度：</p>
<div class="figure align-default" id="id23">
<img alt="_images/image-20230709110933998.png" src="_images/image-20230709110933998.png" />
<p class="caption"><span class="caption-number">Fig. 387 </span><span class="caption-text">image-20230709110933998</span><a class="headerlink" href="#id23" title="Permalink to this image">¶</a></p>
</div>
<p>浮点运算可能精确到小数点后十五位，但仅仅过了这一小步，我们就可以看到能量和角动量的重大误差。
采样误差的原因很明显，因为我们使用初始时间来预测质量在整个时间步长中将做什么。
这是欧拉方法的标志，显然肯定有更好的近似方法。
但首先，我们可以通过循环前面的时间步更新过程，用这种简单的方法绘制轨迹。</p>
</div>
<div class="section" id="id4">
<h3>20.1.2 在单轨道上尝试传统方法<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h3>
<p>理论轨道周期为<span class="math notranslate nohighlight">\(30.476\cdots\)</span>。 如果我们使用 61
个时间步长，每个时间步长为 0.5，则总模拟时间将为
30.5，因此原则上，这应该能够很好地近似一个完整的椭圆轨道。
以下程序尝试执行此操作，将每个 (x、y) 和 (u、v) 时间步结果存储在步骤中。</p>
<div class="figure align-default" id="id24">
<img alt="_images/image-20230709113153132.png" src="_images/image-20230709113153132.png" />
<p class="caption"><span class="caption-number">Fig. 388 </span><span class="caption-text">image-20230709113153132</span><a class="headerlink" href="#id24" title="Permalink to this image">¶</a></p>
</div>
<p>计算出的轨迹如下所示，使用蓝点表示质点 m，使用红点表示质点 M；
我们还以纯绿色显示 m 的正确椭圆轨道形状：</p>
<div class="figure align-default" id="id25">
<img alt="_images/image-20230709113244446.png" src="_images/image-20230709113244446.png" />
<p class="caption"><span class="caption-number">Fig. 389 </span><span class="caption-text">image-20230709113244446</span><a class="headerlink" href="#id25" title="Permalink to this image">¶</a></p>
</div>
<p>“失控的螺旋”这句话在这里确实是正确字面意义了。
模拟未能达到正确性的“眼球度量”：它看起来就是错误的，但这只是因为我们有理论上正确的答案来进行比较。
为了更加定量，我们可以检查最后一个时间步的总能量，与初始条件下的约
-1.15234 的值进行比较。（下标[-1]选择列表的最后一项）：</p>
<div class="figure align-default" id="id26">
<img alt="_images/image-20230709113329014.png" src="_images/image-20230709113329014.png" />
<p class="caption"><span class="caption-number">Fig. 390 </span><span class="caption-text">image-20230709113329014</span><a class="headerlink" href="#id26" title="Permalink to this image">¶</a></p>
</div>
<p>即使没有将结果绘制成图表供人检查，计算机也可以检测并报告能量与正确值相差甚远。
此外，叉积 <span class="math notranslate nohighlight">\(x v - y u\)</span> 从 9 上升到
<span class="math notranslate nohighlight">\(10.944\cdots\)</span>，表明角动量正在向上漂移而不是保持恒定。
尽管自始至终都使用了双精度，和看似坚如磐石的基础物理学，但在所有累积的采样误差之后，结果甚至没有留下一位正确的小数。
如果能量随着更多的时间步长不断增加，它最终会变成正值，质点将飞出而不是处于束缚轨道上！</p>
<p>错误的模拟通常会导致对采样方法的修改。
例如，我们可以尝试使用新旧位置、速度和加速度的平均值来更新位置，就像计算曲线下面积的中点方法一样。
但我们不知道新的位置、速度和加速度，因此我们必须使用粗略的猜测来估计我们需要计算更好的猜测的值。
有很多方案可以进行这种来回猜谜游戏。
一名执业工程师或科学家可能会查阅一本受人尊敬的参考书来查找“最佳”方法，并收到一些传统的建议，例如以下来自《Fortran
数值食谱》第二版的段落：</p>
<blockquote>
<div><p>“对于许多科学运算的用户来说，四阶龙格-库塔法不仅是 ODE
积分器的第一个词，也是最后一个词。
事实上，您可以在这个老黄牛上取得很大的进展，特别是如果您将它与自适应步长算法结合起来。
但请记住，老黄牛的最后一次旅行很可能会带你去济贫院：对于需要极高精确度的问题，Bulirsch-Stoer
或预测校正方法可能会更加有效。 这些方法是高度紧张的赛马。
龙格-库塔法是用来犁地的。”</p>
</div></blockquote>
<p>正确的计算是一门科学，但像上面这样的建议让它听起来像一门艺术，甚至像一个青少年比较跑车。
读完之后，计算机用户可能会得出这样的结论：“不管这些，<strong>我们还是使用更小的时间步长吧</strong>。”</p>
<p>因此，这里再次进行模拟，时间步长是之前的八倍，每个时间步长是之前的八分之一，因此它仍然模拟一个完整的轨道。</p>
<p>当我们绘制更多的点时，图就会变密。 结果显然还是错误的；
用这样的模拟来代替理论或实验并不是健全的科学。
它仍然产生了远离完整轨道的东西，这使得人们对这种计算出的猜测在物理上是否准确缺乏信心。</p>
<div class="figure align-default" id="id27">
<img alt="_images/image-20230709115541702.png" src="_images/image-20230709115541702.png" />
<p class="caption"><span class="caption-number">Fig. 391 </span><span class="caption-text">image-20230709115541702</span><a class="headerlink" href="#id27" title="Permalink to this image">¶</a></p>
</div>
<p>正如计算领域中限制误差的表达式非常不令人满意一样，没有一种教科书时间步进方法可以用可计算数来说明误差的界限；
他们只能说“误差随着时间步长的减小而减小，所以请使用你有耐心等待的最小的时间步长”。
即使您设计出具有数万亿个微小时间步长的十阶时间步长方法，其输出仍然只不过…
… 只是一个猜测。</p>
</div>
<div class="section" id="id5">
<h3>20.1.3 那么区间算术方法呢？<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h3>
<p>如果方程右侧的每个变量都有界限
则方程<span class="math notranslate nohighlight">\(x = x_0 + u_0 t + \frac{1}{2} a t^2\)</span> 和
<span class="math notranslate nohighlight">\(y = y_0 + v_0 t + \frac{1}{2} b t^2\)</span>可以对 x 和 y 进行界限。
人们曾尝试使用区间算术来获得像二体问题这样的动力学计算的严格界限，但效果不佳。
首先，如何加速度求边界并不简单。
如果质量接触，它们的加速度是无限的，速度将达到无穷大。
如果你采取非常短的时间步长，是否可以保证它们不会接触？
不，因为无限速度意味着您可以在大于零的任何时间步长内去任何地方或从任何地方来。
你可以断言“质点在这么小的时间步长内可能不会接触”，但“可能”放弃了有有效保证性，而这本来是开始尝试使用区间界限的原因。
这是一个先有鸡还是先有蛋的问题。</p>
<p>即使您可以限制加速度区间，结果位置的不确定性也会导致加速度的更多不确定性，从而导致位置的不确定性更大，并且边界会快速增长。
一旦边界太大以至于两个质量的可能位置范围实际上重叠，计算就必须停止，因为随着质量之间的距离变为零，加速度将变得无穷大。
或者，边界可以保持恒定大小，并缩短时间步长以避免碰撞，但最终最大的安全时间步长变为零，并且进度再次停止。
区间运算的严格性导致模拟过度严格。</p>
<p>有没有办法阻止二体动力学的有界计算爆炸，从而获得有用的准确度和科学结果而不是猜测？</p>
</div>
</div>
<div class="section" id="ubox">
<h2>20.2 Ubox 方法：初始空间步骤<a class="headerlink" href="#ubox" title="Permalink to this heading">¶</a></h2>
<div class="section" id="id6">
<h3>20.2.1 解决先有鸡还是先有蛋的问题<a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h3>
<table border="2"><tr><td bgcolor="lightblue"><p>米开朗基罗曾经被问到如何雕刻大象。
他回答说：“我会拿一块大石头，把除了大象以外的所有东西都拿走。”</p>
</td></tr></table><p>这正是我们将要采取的方式； 从一块时空开始，将轨迹之外的一切都雕刻掉。
ubox 轨道动力学方法一开始与时间步进完全不同。 与其他 ubox
方法一样，它不会出错。 它将时间视为计算中的另一个自由度。
与钟摆问题一样，它使用空间步来计算时间，而不是相反。</p>
<p><strong>这就解决了先有鸡还是先有蛋的问题</strong>。
它的工作原理非常类似于油漆桶技术，但不跟踪“失败”集。</p>
<p>令人惊讶的是，我们只需要三个自由度：时间 t 和两个质点之一的 x-y 坐标。
（另一个质量的位置再次根据质心位于原点的事实来确定。）速度 u 和 v
实际上可以利用能量守恒和角动量守恒从该位置导出。 轨迹是一组维度为
[t、x、y] 的 ubound。 保证物理上正确的轨迹完全位于计算集内。
我们经常会使用这些维度的子集，具体取决于我们正在做什么；
例如，要求加速度，我们只需要 x 和 y。</p>
<p>像往常一样，我们使用非常低的精度来夸大计算的近似性质，但行为的边界是清楚的。
{2, 3}环境具有较小的动态范围（大约 <span class="math notranslate nohighlight">\(6\times10^{-5}\)</span> 到
<span class="math notranslate nohighlight">\(5\times10^2\)</span>）并且只有一到八位小数。 这些 unum 的大小从 9 位到
19 位不等。
如果我们可以用这么少的位产生像样的有界结果，想象一下我们可以用 {2,
5}环境（精度高达十位小数）来做什么！
下面设置环境，并初始化质量、引力常数等的ubound版本。
我们使用与之前相同的变量名称，但在每个变量名称后附加一个“ub”以提醒我们数量是
ubounds。</p>
<div class="figure align-default" id="id28">
<img alt="_images/image-20230709170417342.png" src="_images/image-20230709170417342.png" />
<p class="caption"><span class="caption-number">Fig. 392 </span><span class="caption-text">image-20230709170417342</span><a class="headerlink" href="#id28" title="Permalink to this image">¶</a></p>
</div>
<p>最初轨迹集合<strong>trojectory</strong>只有一个 ubox，存储初始时间、位置和速度。
我们还将这一点标记为<strong>new</strong>集合中的一个元素，这意味着它可以用于查找解集中的更多其他成员。
这里使用的方法是将ubounds存储在<strong>trojectory</strong>集合中，但将五维ubox存储在<strong>new</strong>集合中。
原因是在 x、y 或 t 维度上不存在<em>包装问题</em>或<em>依赖问题</em>。 x 和 y
上的边界始终是矩形边界，因为坐标是独立的，因此使用 ubound
可以节省存储空间和工作量。 然而当根据 x 和 y
计算速度时，则是一个复杂的形状，因此使用 ubox
元素跟踪形状而不是产生包装问题非常重要。</p>
<div class="figure align-default" id="id29">
<img alt="_images/image-20230709171458689.png" src="_images/image-20230709171458689.png" />
<p class="caption"><span class="caption-number">Fig. 393 </span><span class="caption-text">image-20230709171458689</span><a class="headerlink" href="#id29" title="Permalink to this image">¶</a></p>
</div>
<p>对于引力动力学，在任何时间步长中，两个物体都有可能接触，因为当它们的间隔接近零时，它们的速度接近无穷大。
对于无限速度，这种奇点对于任何大于零的时间步长都是可能的，因此没有明显的方法来限制行为。
但是通过空间步长，我们可以限制加速度，从而限制速度，从而限制该空间步长内可能的位置和时间的集合。</p>
</div>
<div class="section" id="id7">
<h3>20.2.2 首先，框定位置<a class="headerlink" href="#id7" title="Permalink to this heading">¶</a></h3>
<p>空间步长是 ubox 的 x-y 部分周围的一种“缓冲区”，在两个方向上距离 r 。
为了夸大精度损失，我们可以尝试一个相当大的空间步长：用正方形边界包围较小的质点，大小设为例如到原点距离的八分之一。
这保证了空间步不包括原点，因此两个质量块不可能相互接触。
正方形没有什么特别之处； 质量 m
的任何包围形状都可以，只要不会触及相对原点的缩放反射后围绕质点 M
的形状。正方形很容易使用。
根据八分之一规则，如果质量远离原点，空间台阶的直径将自动变大，从而保持加速度的相对不确定性大致相同。
下面从<strong>new</strong>集合中取出 x 和 y 值，并将 ubox
最近角到原点的距离的八分之一（最初为 0.5）分配给 r。</p>
<div class="figure align-default" id="id30">
<img alt="_images/image-20230709173009714.png" src="_images/image-20230709173009714.png" />
<p class="caption"><span class="caption-number">Fig. 394 </span><span class="caption-text">image-20230709173009714</span><a class="headerlink" href="#id30" title="Permalink to this image">¶</a></p>
</div>
<p>下图是展示质点1的最后一张图；
此后，我们只关注质点2的轨迹。该图提醒我们，质点 2
上的任何空间步长都会自动在质点 1 上放置相应的界限，所有内容均按
<span class="math notranslate nohighlight">\(\frac{m}{M}\)</span> 比例缩放</p>
<div class="figure align-default" id="id31">
<img alt="_images/image-20230709173331147.png" src="_images/image-20230709173331147.png" />
<p class="caption"><span class="caption-number">Fig. 395 </span><span class="caption-text">image-20230709173331147</span><a class="headerlink" href="#id31" title="Permalink to this image">¶</a></p>
</div>
<p>给定任何有限 ubox（具有大于零的任意维数）和半径 r，参考实现中的
<strong>spacestepbounds</strong>[ ubox, r ] 函数返回一个 ubound
列表，每个维度一个，可用于测试以查看 如果其他 ubox 与内部相交。
在每个维度上，它始终是开放边界，而不是封闭边界。
<strong>trials</strong>集最初只是这个单一的方块。</p>
<div class="figure align-default" id="id32">
<img alt="_images/image-20230709173502488.png" src="_images/image-20230709173502488.png" />
<p class="caption"><span class="caption-number">Fig. 396 </span><span class="caption-text">image-20230709173502488</span><a class="headerlink" href="#id32" title="Permalink to this image">¶</a></p>
</div>
<p>下一页的图显示了由空间台阶边界包围的琥珀色试验区域。
为了强调算法对轨迹一无所知，我们显示了几个尖端带有问号的箭头</p>
<div class="figure align-default" id="id33">
<img alt="_images/image-20230709173554110.png" src="_images/image-20230709173554110.png" />
<p class="caption"><span class="caption-number">Fig. 397 </span><span class="caption-text">image-20230709173554110</span><a class="headerlink" href="#id33" title="Permalink to this image">¶</a></p>
</div>
<p>大的空间步长将清楚地表明加速度在质量块的运动范围内可以变化多少。
我们所需要的只是加速度的有限界限，以开始迭代细化。
与往常一样，计算机可以自动选择 unum 精度、最小 ULP
大小和空间步长，以使所有精度损失保持一致。</p>
<p><strong>accub</strong>[{xub,yub}] 函数是 <strong>acc</strong>[{x,y}] 的 unum 算术版本。
它限制位于由 ubounds {xub, yub} 描述的矩形内的质点 <strong>mub</strong> 的加速度。
它返回一对 ubound 加速度值：一个用于 x 方向，一个用于 y 方向。
有两种方法可以完成创建此类边界的任务。 这是一个快速有效的方法：</p>
<div class="figure align-default" id="id34">
<img alt="_images/image-20230709173736224.png" src="_images/image-20230709173736224.png" />
<p class="caption"><span class="caption-number">Fig. 398 </span><span class="caption-text">image-20230709173736224</span><a class="headerlink" href="#id34" title="Permalink to this image">¶</a></p>
</div>
<p>这对于 ULP 大小的矩形效果很好，但由于加速度公式的分子和分母都有 x 或
y，因此依赖问题会导致一些精度损失。 这可以通过附录 D.7
中所示的稍微复杂的<strong>accub</strong> 函数来消除。
如前所述，每当特定函数对计算变得至关重要时，寻找最小值和最大值并创建更紧密的界限（例如计算数字的平方）通常会很有帮助。
创建这样的函数对于 unums 和 uboxes
的用户来说并<em>不是</em>一项强制性技能，就像区间算术那样，但如果您是那种想要追踪并粉碎一系列计算中所有不必要的
ULP 大小的信息丢失的人， 这个选项就在那里。</p>
<p>通过评估空间台阶内部的 <strong>accub</strong> 并找到 x 和 y
范围内加速度的最大值和最小值，我们获得了有关质点轨迹的大量信息。
请注意，空间步内每个 x-y ubound
对的加速度求值可以轻松并行完成，因为它是不同 ubox
上的相同操作（数据并行性）。 下一页的<strong>boundacc</strong>[set] 函数计算set
中每个x-y ubound 对的加速度，并以一对ubounds 返回最小值和最大值。</p>
<div class="figure align-default" id="id35">
<img alt="_images/image-20230709215222156.png" src="_images/image-20230709215222156.png" />
<p class="caption"><span class="caption-number">Fig. 399 </span><span class="caption-text">image-20230709215222156</span><a class="headerlink" href="#id35" title="Permalink to this image">¶</a></p>
</div>
<p>这是 x 和 y 方向上的初始加速度界限：</p>
<div class="figure align-default" id="id36">
<img alt="_images/image-20230709215306053.png" src="_images/image-20230709215306053.png" />
<p class="caption"><span class="caption-number">Fig. 400 </span><span class="caption-text">image-20230709215306053</span><a class="headerlink" href="#id36" title="Permalink to this image">¶</a></p>
</div>
<p>这些加速度的界限是宽松的，因为空间步长相对于两个质点的距离来说是如此之大。
但它们是还是有界的，这足以开始细化过程。 下一步是计算试验轨迹的 x-y
部分，应用恒定加速度下位置常用公式的 unum 版本。 （通过使用第 16
章的无损多项式例程，我们可以避免任何不必要的信息丢失。）</p>
<div class="figure align-default" id="id37">
<img alt="_images/image-20230710081849083.png" src="_images/image-20230710081849083.png" />
<p class="caption"><span class="caption-number">Fig. 401 </span><span class="caption-text">image-20230710081849083</span><a class="headerlink" href="#id37" title="Permalink to this image">¶</a></p>
</div>
<p>应用此方法来增加 t 的值，直到计算出的 x 和 y 完全超出空间界限。 由于 a
和 b
受到严格限制，因此这些公式考虑了质量在空间步长内可能存在的每个可能位置。</p>
<table border="2"><tr><td bgcolor="lightblue"><p>没有空间或时间的“采样”，因为 unums 平铺了一系列实数，没有遗漏任何数字。
时间只是另一个维度，因此时间可以作为 ubox 集前进，在精确值和 ULP
尺度的开放区间之间交替。</p>
</td></tr></table><p>例如，如果 t 的首选 minpower 设置为 –6，则首选最小 ULP 大小为
<span class="math notranslate nohighlight">\(2^{-6} = 1/64\)</span> 。 以下 unum 例程找到一组将轨迹限制在空间步内的
ubox，并将其存储在trials中。
它还分配了一些适合稍后的其他轨迹值的minpower。</p>
<div class="figure align-default" id="id38">
<img alt="_images/image-20230710082629005.png" src="_images/image-20230710082629005.png" />
<p class="caption"><span class="caption-number">Fig. 402 </span><span class="caption-text">image-20230710082629005</span><a class="headerlink" href="#id38" title="Permalink to this image">¶</a></p>
</div>
<p>轨道（用蓝色箭头显示）保证位于重叠的琥珀色矩形（左侧）内。 这组可能的 x
和 y 位置构成了比原始空间步长小得多的集合。
事实上，它看起来已经像是轨道计算了。</p>
<div class="figure align-default" id="id39">
<img alt="_images/image-20230710083732553.png" src="_images/image-20230710083732553.png" />
<p class="caption"><span class="caption-number">Fig. 403 </span><span class="caption-text">image-20230710083732553</span><a class="headerlink" href="#id39" title="Permalink to this image">¶</a></p>
</div>
<p>这意味着我们可以评估这个更有限的空间范围内的加速度并获得改进的加速度界限。
界限永远不可能一直收紧到精确值，因为加速度并不精确；
它在空间步长内变化。 关键是要使这种变化与用于计算的 unum
的准确性保持一致。</p>
<p>这是新的加速度范围：</p>
<div class="figure align-default" id="id40">
<img alt="_images/image-20230710083314597.png" src="_images/image-20230710083314597.png" />
<p class="caption"><span class="caption-number">Fig. 404 </span><span class="caption-text">image-20230710083314597</span><a class="headerlink" href="#id40" title="Permalink to this image">¶</a></p>
</div>
<p>对加速度的限制要严格得多。 有了这些改进的信息，我们就可以重复位置计算。
重复此交替过程的自动循环很快就会收敛。
与使用浮点数的计算不同，不需要选择任意点来停止迭代；
最终，迭代产生与之前完全相同的位置信息，但受到精度的限制，因此没有理由再次执行。
计算可以监控信息（ubox总体积的倒数）。
当信息不再增加时，就该停止迭代了。 第一阶段结束。</p>
<p>第 2
阶段迭代做了一些微妙的改变：时间前进，直到轨迹到达空间步长边界之外的任何地方。
我们希望在轨迹超出边界之前使用最大精确的 unum 时间。 该测试是将计算出的
x-y 位置与空间边界内部相交。</p>
<p>一旦交集与计算的 x-y
位置不同，就意味着某些内容已被空间步长边界剪掉，我们需要退回到上一个时间步长。
这样，我们将在最长时间内拥有一整套可能的 x-y 位置。
在第二阶段，时间被附加到每组可能的位置上； 因此，我们有一个轨迹 ubound
集的起点，而不仅仅是轨道的位置部分。</p>
<div class="figure align-default" id="id41">
<img alt="_images/image-20230710084513414.png" src="_images/image-20230710084513414.png" />
<p class="caption"><span class="caption-number">Fig. 405 </span><span class="caption-text">image-20230710084513414</span><a class="headerlink" href="#id41" title="Permalink to this image">¶</a></p>
</div>
<p>这是轨迹边界，以时间为垂直维度。
它是一种螺旋楼梯，其台阶（相当于行进方法的时间步长）只有一个 ULP 高。</p>
<p>与传统的数值方法不同，计算出的轨迹是可证明的界限，而不是猜测。
然而，它只需要很少的存储空间。 即使可以使用浮点数进行严格计算，以 IEEE
64 位精度存储第一个空间步轨迹也需要 10 752 位。
trials集需要六分之一的存储空间。 由于乘法和加法仅使用 1 到 4 位指数和 1
到 8 位分数，因此硬件中的 unum 可能会比双精度浮点数快一个数量级，即使
unum 逻辑的复杂性更高 。</p>
<div class="figure align-default" id="id42">
<img alt="_images/image-20230710084658634.png" src="_images/image-20230710084658634.png" />
<p class="caption"><span class="caption-number">Fig. 406 </span><span class="caption-text">image-20230710084658634</span><a class="headerlink" href="#id42" title="Permalink to this image">¶</a></p>
</div>
<p>请注意矩形块如何以几乎不重叠其角的方式相互接触。
重叠是精确的时间计算，并且表明计算比看起来要精确得多。
图中蓝色显示了穿过楼梯台阶重叠的小矩形的轨迹，而且时间是准确的，因为真正的边界是一组缝合在一起的抛物线。
实际上，空间步骤产生了许多精确的时间步骤，而不仅仅是一个。</p>
<p>这是一个近距离视图，显示了穿过 ubox 角的非常轻微重叠的轨迹。</p>
<div class="figure align-default" id="id43">
<img alt="_images/image-20230710085424741.png" src="_images/image-20230710085424741.png" />
<p class="caption"><span class="caption-number">Fig. 407 </span><span class="caption-text">image-20230710085424741</span><a class="headerlink" href="#id43" title="Permalink to this image">¶</a></p>
</div>
<p>如果 x-y 范围在最后一个精确时间超过几个 ULP 宽，则表明空间步长半径 r
对于所使用的精度而言太大。
然后，我们可以减小空间步长半径的大小，从而减少力的变化，从而使采样变化更接近一个
ULP 的大小。 或者，因为 unum
精度完全可以调整到位级别，所以解决方法可能是降低环境的精度。
如果最后一个精确时间的 ULP 数量始终恰好为
1，则表明空间步长太小，应增加空间步长，或者可以提高精度。
轨道计算的应用程序可以自动进行这些调整；
用户所要做的就是在轨迹中表达所需的精度。
该程序还可能自动考虑可用硬件中的并行量，并在每次迭代中允许更多 ULP，因为
x 和 y 维度中的 ubox 可以并行计算</p>
<p>在此示例中，最后一个精确时间轨迹是 x 和 y 维度中的单个 ubox：t =
0.21875、x = (3.9765625、3.984375)、y = (0.48828125、0.4921875)。
也就是说，最后一次只有一个位置，并且它在 x 和 y 维度上恰好只有一个 ULP
宽度。</p>
<p>在更一般的情况下，任何具有一对端点的 ubound 结果都将使用 <strong>uboxlist</strong>
进行分割，以便新的起点始终只有一个 ULP 宽。
最后一个时间步长连同当时的速度一起保存在<strong>laststate</strong>中，并且<strong>trials</strong>集与<strong>trajectory</strong>集结合在一起。
在使用 <span class="math notranslate nohighlight">\(u = u_0 + (t - t_0) a\)</span> 和 <span class="math notranslate nohighlight">\(v = v_0 + (t - t_0) b\)</span>
更新速度时，我们使用融合乘加来防止边界中任何不必要的扩展；
在这种情况下，它不会影响结果，但这是一个值得养成的好习惯。</p>
<div class="figure align-default" id="id44">
<img alt="_images/image-20230710090140831.png" src="_images/image-20230710090140831.png" />
<p class="caption"><span class="caption-number">Fig. 408 </span><span class="caption-text">image-20230710090140831</span><a class="headerlink" href="#id44" title="Permalink to this image">¶</a></p>
</div>
<p><strong>laststate</strong>集现在拥有开始下一个空间步进需的一切。 不再需要加速度值
{a，b} 和旧的 <span class="math notranslate nohighlight">\(t_0\)</span>。</p>
</div>
</div>
<div class="section" id="id8">
<h2>20.3 下一个开始点，和一些强制状态法则<a class="headerlink" href="#id8" title="Permalink to this heading">¶</a></h2>
<p>要从任何 t-x-y 启动另一个空间步骤，我们需要新的速度起始值
<span class="math notranslate nohighlight">\(u_{new}\)</span> 和 <span class="math notranslate nohighlight">\(v_{new}\)</span>。
可以应用三个约束来增加有关新速度的信息：</p>
<p>明显的出发点是：速度的变化是加速度乘以时间的变化。
<span class="math notranslate nohighlight">\(\{u, v\}_{new} = \{u, v\}_{old} + \{a, b\}t\)</span>，其中 t
是精确开始时间与最后精确结束时间之间的差值，<span class="math notranslate nohighlight">\(\{u, v\}_{old}\)</span> 和
<span class="math notranslate nohighlight">\(\{a, b\}\)</span> 的不确定性范围为 一般的。 这会在 u-v
平面中创建一个矩形边界，因为这些边界是独立的。 这是在上一节末尾计算 u 和
v 新值的简单方法。</p>
<p>第二个约束是能量守恒定律，u 和 v 绝对不是独立的。 请记住，总能量是</p>
<div class="math notranslate nohighlight" id="equation-20-two-body-problem-0">
<span class="eqno">(90)<a class="headerlink" href="#equation-20-two-body-problem-0" title="Permalink to this equation">¶</a></span>\[e=\frac{m(M+m)}{2M}(u^2+v^2)-(\frac{GmM^2}{M+m})\frac{1}{\sqrt{x^2+y^2}}\]</div>
<p>x 和 y 值有一个范围，这意味着如果能量相对于其初始值 e0 没有变化，则
<span class="math notranslate nohighlight">\(u^2 + v^2\)</span> 上有一个界限：</p>
<div class="math notranslate nohighlight" id="equation-20-two-body-problem-1">
<span class="eqno">(91)<a class="headerlink" href="#equation-20-two-body-problem-1" title="Permalink to this equation">¶</a></span>\[C_1e_0+\frac{C_2}{\sqrt{\text{Maximum}(x^2+y^2)}} \le u^2+v^2 \le C_1e_0+\frac{C_2}{\sqrt{\text{Minimum}(x^2+y^2)}}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(C_1\)</span> 和 <span class="math notranslate nohighlight">\(C_2\)</span> 是涉及 m、M 和 G 的常数。由于
<span class="math notranslate nohighlight">\(u^2 + v^2 = r^2\)</span> 在 u-v 平面中定义了一个半径为 r 的圆，因此
<span class="math notranslate nohighlight">\(u^2 + v^2\)</span> 上的界限意味着 u 和 v 的值位于圆内，如下所示
下图中浅蓝色所示：</p>
<div class="figure align-default" id="id45">
<img alt="_images/image-20230710093221894.png" src="_images/image-20230710093221894.png" />
<p class="caption"><span class="caption-number">Fig. 409 </span><span class="caption-text">image-20230710093221894</span><a class="headerlink" href="#id45" title="Permalink to this image">¶</a></p>
</div>
<p>u 和 v 的第三个约束是角动量守恒定律。 由于 ULP 范围内的不精确运算，叉积
<span class="math notranslate nohighlight">\(x v - y u\)</span>
将是一个范围，但它应始终包含原始值<span class="math notranslate nohighlight">\(cross_0\)</span>。
从图形上看，此约束看起来像 u-v
平面中的一条带，在穿过轴的地方稍微弯曲，如洋红色所示：</p>
<div class="figure align-default" id="id46">
<img alt="_images/image-20230710093748811.png" src="_images/image-20230710093748811.png" />
<p class="caption"><span class="caption-number">Fig. 410 </span><span class="caption-text">image-20230710093748811</span><a class="headerlink" href="#id46" title="Permalink to this image">¶</a></p>
</div>
<p>传统的区间算术会让您创建一个函数来描述上面的类似领结的形状，该函数考虑 x
和 y 所在的象限来查找边界线的斜率和轴截距，包括避免除以的特殊情况 零。
该代码大约需要半页。 以下是参考实现中使用 unum 算术进行测试的情况：</p>
<div class="figure align-default" id="id47">
<img alt="_images/image-20230710093900299.png" src="_images/image-20230710093900299.png" />
<p class="caption"><span class="caption-number">Fig. 411 </span><span class="caption-text">image-20230710093900299</span><a class="headerlink" href="#id47" title="Permalink to this image">¶</a></p>
</div>
<p>我们只需应用第 17
章中表达的哲学：不需要“求解”方程，即通过求逆运算来获得用另一个值表示的一个值。
只需插入四维 ubox 的值，看看它是否符合规定，True 或 False。
在新的起始集中丢弃不合规的 ubox 通常会消除大约一半的
ubox，这不仅节省了工作量并收紧了界限，而且可以更好地模拟实际的物理行为。</p>
<p>以下是参考实现中 <strong>complianceQ</strong> 测试的样子：</p>
<div class="figure align-default" id="id48">
<img alt="_images/image-20230710094018429.png" src="_images/image-20230710094018429.png" />
<p class="caption"><span class="caption-number">Fig. 412 </span><span class="caption-text">image-20230710094018429</span><a class="headerlink" href="#id48" title="Permalink to this image">¶</a></p>
</div>
<p>请记住，<strong>laststate</strong> 具有与 <strong>new</strong> 相同的形式：t、x、y、u、v 的
ubounds。为什么不像我们使用 <strong>new</strong> 那样简单地使用 <strong>laststate</strong>
来开始下一个空间步骤？ 这是区间算术和 ubox 方法之间的另一个关键区别。
始终将laststate的ubound 拆分为 ULP 大小的 ubox。
这样，每个空间步的精度损失将大致相同，并且轨迹界限将线性增长。
使用区间算术，界限的增长速度至少与空间步数的平方一样快，并且很快界限就会包含原点并创建除以零的结果。</p>
<div class="figure align-default" id="id49">
<img alt="_images/image-20230710094230721.png" src="_images/image-20230710094230721.png" />
<p class="caption"><span class="caption-number">Fig. 413 </span><span class="caption-text">image-20230710094230721</span><a class="headerlink" href="#id49" title="Permalink to this image">¶</a></p>
</div>
<p>因此，new 中的条目在任何维度上都不会超过一个 ULP。
为了显示守恒测试的敏感性，以下是合规性测试后起始集的 u-v 尺寸：</p>
<div class="figure align-default" id="id50">
<img alt="_images/image-20230710101515418.png" src="_images/image-20230710101515418.png" />
<p class="caption"><span class="caption-number">Fig. 414 </span><span class="caption-text">image-20230710101515418</span><a class="headerlink" href="#id50" title="Permalink to this image">¶</a></p>
</div>
<p>v 的 ubox 列表产生了七个元素。 只有一个符合要求，以青色显示；
其他失败并显示为红色。 浅蓝色弧线是能量守恒的环。
浅洋红色带是角动量守恒的区域。 只有青色 ubox
与两个区域相交通过，从而对有关轨迹的信息提高了四倍。</p>
<p>对于浮点数，我们只能<em>希望</em>计算结果与能量和角动量守恒一致。
一般来说，它们不是。 在传统的数值模拟中，您可能会想通过调整 x、y、u 或 v
来“纠正”能量和角动量的偏差，以保持这些量恒定。
问题是，您调整四个变量中的哪一个？ 有什么数学或物理依据？
这种纠正技术甚至有自己历史悠久的俚语：“捏造”(Fudging)答案。</p>
<p>有了 uboxes，就不存在捏造的情况了。
我们可以通过<em>消除任何不遵守守恒定律的 ubox</em> 来严格执行守恒定律。
检查哪些 xy-u-v 组合违反能量和角动量守恒是另一项易于并行执行的任务。
<strong>enforcelaw</strong>[state] 函数接受任何 t-x-y-u-v ubounds 集合，将其拆分为
ubox，并返回符合定律值的集合。 在 <strong>laststate</strong>
上使用它可以为接下来的空间步骤提供一组起点：</p>
<div class="figure align-default" id="id51">
<img alt="_images/image-20230710102859013.png" src="_images/image-20230710102859013.png" />
<p class="caption"><span class="caption-number">Fig. 415 </span><span class="caption-text">image-20230710102859013</span><a class="headerlink" href="#id51" title="Permalink to this image">¶</a></p>
</div>
<p>一般来说，enforcelaw 会修剪掉计算轨迹 ubox
集中的大量“脂肪”，因为它认识到 u 和 v
对位于复杂的形状内，而不是简单的矩形边界内。</p>
</div>
<div class="section" id="id9">
<h2>20.4 通用的空间步进<a class="headerlink" href="#id9" title="Permalink to this heading">¶</a></h2>
<p>第一个空间步进是从一个精确的 ubox 开始的。
一般来说，我们从一组位置和速度可能不准确的 ubox 开始； 我们从计算的轨迹
ubox 中选择了准确的时间。 每个起始 ubox
都会在其自己的空间框中产生自己的轨迹，并按照我们第一步的方式针对加速范围进行了细化。
然后它与已知的轨迹盒集合并，但有一个小问题需要注意：当合并两个轨迹集时，我们找到每个轨迹集达到的最大时间，并丢弃任何大于这两个最大时间最小值的
ubox。 这样，我们可以再次选择一个精确的时间作为下一个空间步骤的起点。</p>
<p>在传统的间隔中，每个时间步的起始值的不确定性迅速变大，导致加速度的范围越来越宽，使得位置上的界限很快就包含了原点；
模拟在那时就爆炸了。</p>
<table border="2"><tr><td bgcolor="lightblue"><center><p>对于 ubox 轨迹，初始条件始终是最小 ULP
大小，因此每个轨迹的不确定性不会增加。</p>
</center></td></tr></table><p>大多数轨迹是重叠的，因此不确定性的扩展大致是线性的，而不是灾难性地快速增长。
ubox
以透明方式显示，并且由于几乎相同的轨迹重叠，第二个空间步骤显得更暗。</p>
<p><strong>findtraj</strong>[ubox] 函数的作用与前面的空间步长计算完全相同，使用
<strong>ubox</strong> 作为位置和速度的起点。 该代码只是前面显示的每个阶段的合并。</p>
<div class="figure align-default" id="id52">
<img alt="_images/image-20230710104237161.png" src="_images/image-20230710104237161.png" />
<p class="caption"><span class="caption-number">Fig. 416 </span><span class="caption-text">image-20230710104237161</span><a class="headerlink" href="#id52" title="Permalink to this image">¶</a></p>
</div>
<p>下图是第三个空间步骤结束时的轨迹特写，大约是绕完整轨道的 2%。 x、y 和 t
维度的精度损失在该比例下表现为重叠的 ubox。
误差没有指数增长，只有线性增长。</p>
<div class="figure align-default" id="id53">
<img alt="_images/image-20230710104857720.png" src="_images/image-20230710104857720.png" />
<p class="caption"><span class="caption-number">Fig. 417 </span><span class="caption-text">image-20230710104857720</span><a class="headerlink" href="#id53" title="Permalink to this image">¶</a></p>
</div>
<p>请注意，所有 x-y 范围的并集并不总是矩形；
守恒定律剪掉了楼梯顶部台阶的一个角。
在如此低的精度下继续前进是没有意义的。
卡汉注意到“角”似乎会导致动力学问题中区间界限的快速扩展，并创建了一个轨道模拟器，使用超椭球来表示每个质量的状态。
卡汉的方法似乎还表现出随着每个时间步长，误差仅线性增加。 ubox
方法可以显示卡汉观察的实证验证。</p>
<table border="2"><tr><td bgcolor="lightblue"><p>这个例子表明，获得紧密间隔不能通过高数值精度或高阶采样方法来实现，而只需简单使用高中所教授的物理和数学知识，并让计算机使用可靠的算术即可实现。</p>
</td></tr></table><p>假设该方法应用于日地系统，并想象我们以某种方式准确了解太阳和地球的质量以及引力常数。
ubox 方法预测地球绕太阳一周后的位置有多准确？ 如果使用 {3, 6}
的环境（分数中的精度高达 <span class="math notranslate nohighlight">\(2^6 = 64\)</span> 位），则大约 100
米的空间步长将在加速度中产生大约一个最小可能的 ULP 范围。 大约 90
亿个空间步就足以完成一个完整的轨道运行，但信息损失约为 90 亿个 ULP。
计算出来的误差约为两公里。</p>
<p>换句话说，如果我们忽略太阳系中的所有其他质量和广义相对论的微小影响，ubox
方法可以以 0.07 秒的精度预测一年的持续时间。</p>
</div>
<div class="section" id="id10">
<h2>20.5 三体问题<a class="headerlink" href="#id10" title="Permalink to this heading">¶</a></h2>
<div class="figure align-default" id="id54">
<img alt="_images/image-20230710105706854.png" src="_images/image-20230710105706854.png" />
<p class="caption"><span class="caption-number">Fig. 418 </span><span class="caption-text">image-20230710105706854</span><a class="headerlink" href="#id54" title="Permalink to this image">¶</a></p>
</div>
<blockquote>
<div><p>上图是电影《影子的游戏》中的一个画面。
当阿瑟·柯南·道尔爵士创造了夏洛克·福尔摩斯的宿敌时，他从那个时代的数学家和天文学家那里汲取了灵感，他们竞相试图成为第一个解决几个世纪以来一直无法解决的引力动力学问题的人。
1914 年，托雷斯·伊·克瓦多 (Torres y Quevado)
提出浮点用于自动计算，同年，道尔发表了短篇小说《恐惧之谷》，描述了莫里亚蒂在引力动力学方面的杰出成就。故事背景设定在
1888 年，即一般三体问题是无法解决的证明发表一年后。</p>
</div></blockquote>
<p>艾萨克·牛顿 (Isaac Newton)
是第一个寻找日地-月球系统运动的解析解的人，那是1687年。毕竟他成功地为开普勒的观测结果找到了解析证据，即行星绕太阳运行的椭圆轨道，
也就是二体问题。
再找到控制三个物体在万有引力作用下的行为的数学有多困难呢？</p>
<p>那可<em>困难得多了</em>。
经过许多杰出思想家几个世纪的失败尝试后，亨利·庞加莱和恩斯特·布伦斯在
1887
年表明，即使您允许使用无人知道如何求值的积分来表达答案，一般问题也没有解析解。
三体系统中的轨迹通常是不重复的，即混沌的。
建立不稳定问题也很容易，这意味着初始速度和位置的微小变化会导致轨迹发生很大的变化。
即使是现在，距离牛顿尝试解决这个问题已有 327
年了，数学物理学家仍在不断研究三体问题的一个又一个特例，而这些特例恰好是传统意义上“可解”的可解。</p>
<p>前面的两体引力动力学方法很容易扩展到多体。
作者使用空间步进和每步仅增长约 1 个 ULP
的边界，在模拟低精度环境中限制了三体问题在三个维度上的行为。
这就提出了一个问题：“解决”三体问题意味着什么？</p>
<p>这个问题的最初提出者可能正在设想类似二体轨道的代数公式，黑板上覆盖着正弦、余弦和平方根。
但是，如果“求解”意味着<em>使用有限的运算将答案求解到任意精度范围内</em>呢？
如果一个过程通过有限的工作量产生了所需的尽可能多的信息，这难道不构成问题的解决方案吗？
如果允许的话，三体问题可以用ubox方法来解决。
没有任何形式的警告或限制。可以是稳定或不稳定的，重复或混沌的。
如果行为不稳定或混沌，那是因为真正的物理行为不稳定或混沌，而不是因为数值方法！</p>
<p>将二体方法扩展到三体的细节并不适合阅读，总结一些要点如下：</p>
<ul class="simple">
<li><p>由于质心不对称，因此需要跟踪每个物体的位置和速度。</p></li>
<li><p>运动不一定是平面的，因此 ubox 涉及每个质点的 x、y 和 z 位置和速度。</p></li>
<li><p>在过滤“合规”ubox 时，角动量具有三个维度，而不是一个维度。</p></li>
<li><p>除了能量和角动量之外，线性动量守恒和质心运动也是合规性测试的一部分。</p></li>
<li><p>ubox 有 19 个维度：三个物体中的每一个都具有位置和速度的三个维度，总共
18 个维度。 加上时间维度是19。</p></li>
</ul>
<p>下图显示了三维三体问题的前几个空间步骤，具有严格的 ubox
边界，精度非常低：2 位指数，4 位分数。 每条轨迹都被互补色的 ubox
包围，这些 ubox 被证明无法触及轨迹。</p>
<div class="figure align-default" id="id55">
<img alt="_images/image-20230710112049776.png" src="_images/image-20230710112049776.png" />
<p class="caption"><span class="caption-number">Fig. 419 </span><span class="caption-text">image-20230710112049776</span><a class="headerlink" href="#id55" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="n">
<h2>20.6 n-体问题和星系对撞<a class="headerlink" href="#n" title="Permalink to this heading">¶</a></h2>
<div class="figure align-default" id="id56">
<img alt="_images/image-20230710112149032.png" src="_images/image-20230710112149032.png" />
<p class="caption"><span class="caption-number">Fig. 420 </span><span class="caption-text">image-20230710112149032</span><a class="headerlink" href="#id56" title="Permalink to this image">¶</a></p>
</div>
<blockquote>
<div><p>大约四十亿年后，银河系将与仙女座星系发生碰撞。
许多超级计算机用户已经建立了涉及数十亿个个体质量在引力作用下相互作用的模拟，并生成了许多像上图这样的华丽图形。
但有一个问题。</p>
</div></blockquote>
<p>一些计算科学家已经推动他们的时间步进 n
体模拟能够处理超过一万亿个相互作用的物体，使他们能够模拟整个星系的碰撞。
虽然这些图片看起来令人惊叹，但更令人惊讶的是模拟中的科学有效性是如此之少。
请记住，两个物体之间的引力是</p>
<div class="math notranslate nohighlight" id="equation-20-two-body-problem-2">
<span class="eqno">(92)<a class="headerlink" href="#equation-20-two-body-problem-2" title="Permalink to this equation">¶</a></span>\[F=\frac{GmM}{r^2}\]</div>
<p>其中 r 是物体之间的距离。
计算机模拟显示，大量具有成对相互作用的质点的会出现结果爆炸(溢出)的趋势，因为很有可能某一次成对相互作用r
很接近于零。 因此，令人震惊的解决方法是，这是 n
体研究界的一个肮脏的小秘密，就是使用这个力方程：</p>
<div class="math notranslate nohighlight" id="equation-20-two-body-problem-3">
<span class="eqno">(93)<a class="headerlink" href="#equation-20-two-body-problem-3" title="Permalink to this equation">¶</a></span>\[F=\frac{GmM}{r^2+q}\]</div>
<p>其中分母中的 q
是程序员选择的一个模糊数字，这似乎可以防止答案看起来错误。
但它没有科学依据。
如果要求星系对撞机使用用于星系的相同软件来解决二体问题，结果很可能会出现令人尴尬的错误。
然而用户正在模拟数百万或数十亿的交互质点就可以了。</p>
<p>许多计算机模拟非常漂亮，但作为科学，只有当它们实际上是<em>正确</em>时，才会变得更加有趣</p>
</div>
</div>


        </div>
        <div class="side-doc-outline">
            <div class="side-doc-outline--content"> 
<div class="localtoc">
    <p class="caption">
      <span class="caption-text">Table Of Contents</span>
    </p>
    <ul>
<li><a class="reference internal" href="#">20 二体问题(以及多体问题)</a><ul>
<li><a class="reference internal" href="#id2">20.1 多维微分方程</a><ul>
<li><a class="reference internal" href="#id3">20.1.1 设置传统模拟</a></li>
<li><a class="reference internal" href="#id4">20.1.2 在单轨道上尝试传统方法</a></li>
<li><a class="reference internal" href="#id5">20.1.3 那么区间算术方法呢？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ubox">20.2 Ubox 方法：初始空间步骤</a><ul>
<li><a class="reference internal" href="#id6">20.2.1 解决先有鸡还是先有蛋的问题</a></li>
<li><a class="reference internal" href="#id7">20.2.2 首先，框定位置</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id8">20.3 下一个开始点，和一些强制状态法则</a></li>
<li><a class="reference internal" href="#id9">20.4 通用的空间步进</a></li>
<li><a class="reference internal" href="#id10">20.5 三体问题</a></li>
<li><a class="reference internal" href="#n">20.6 n-体问题和星系对撞</a></li>
</ul>
</li>
</ul>

</div>
            </div>
        </div>

      <div class="clearer"></div>
    </div><div class="pagenation">
     <a id="button-prev" href="19_pendulums_done_correctly.html" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--colored" role="botton" accesskey="P">
         <i class="pagenation-arrow-L fas fa-arrow-left fa-lg"></i>
         <div class="pagenation-text">
            <span class="pagenation-direction">Previous</span>
            <div>19 摆的正确计算</div>
         </div>
     </a>
     <a id="button-next" href="21_calculus_evil.html" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--colored" role="botton" accesskey="N">
         <i class="pagenation-arrow-R fas fa-arrow-right fa-lg"></i>
        <div class="pagenation-text">
            <span class="pagenation-direction">Next</span>
            <div>21 微积分被认为是邪恶的：离散物理</div>
        </div>
     </a>
  </div>
        
        </main>
    </div>
  </body>
</html>